CCS PCM C Compiler, Version 4.130, 59972               19-nov.-14 19:56

               Filename: C:\Users\Ivan-ua\Documents\PIC\Pic C\P10\cerradura-ee.lst

               ROM used: 1798 words (88%)
                         Largest free fragment is 250
               RAM used: 36 (16%) at main() level
                         54 (24%) worst case
               Stack:    5 locations

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   3E9
0003:  NOP
.................... #include <16f628a.h> 
.................... //////// Standard Header file for the PIC16F628A device //////////////// 
.................... #device PIC16F628A 
.................... #list 
....................  
.................... #fuses INTRC 
.................... #fuses NOWDT 
.................... #fuses NOMCLR 
.................... #fuses NOPUT 
.................... #fuses NOLVP 
.................... #fuses NOPROTECT 
.................... #fuses NOCPD 
.................... #fuses NOBROWNOUT 
.................... #use delay(clock=4000000) 
*
012D:  MOVLW  47
012E:  MOVWF  04
012F:  BCF    03.7
0130:  MOVF   00,W
0131:  BTFSC  03.2
0132:  GOTO   141
0133:  MOVLW  01
0134:  MOVWF  78
0135:  CLRF   77
0136:  DECFSZ 77,F
0137:  GOTO   136
0138:  DECFSZ 78,F
0139:  GOTO   135
013A:  MOVLW  4A
013B:  MOVWF  77
013C:  DECFSZ 77,F
013D:  GOTO   13C
013E:  GOTO   13F
013F:  DECFSZ 00,F
0140:  GOTO   133
0141:  RETURN
.................... #BYTE TRISA=0x85 
.................... #BYTE PORTA=0x05 
.................... #BYTE TRISB=0x86 
.................... #BYTE PORTB=0x06 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
03F3:  CLRF   20
03F4:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................                                                
.................... #define LCD_ENABLE_PIN  PIN_A0                                     
.................... #define LCD_RS_PIN      PIN_A1                                     
.................... #define LCD_RW_PIN      PIN_A2                                     
.................... #define LCD_DATA4       PIN_B4                                     
.................... #define LCD_DATA5       PIN_B5                                     
.................... #define LCD_DATA6       PIN_B6                                     
.................... #define LCD_DATA7       PIN_B7 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01A6:  BSF    06.4
....................    output_float(LCD_DATA5); 
01A7:  BSF    06.5
....................    output_float(LCD_DATA6); 
01A8:  BSF    06.6
....................    output_float(LCD_DATA7); 
01A9:  BSF    06.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01AA:  BCF    03.5
01AB:  BSF    05.2
01AC:  BSF    03.5
01AD:  BCF    05.2
....................    delay_cycles(1); 
01AE:  NOP
....................    lcd_output_enable(1); 
01AF:  BCF    03.5
01B0:  BSF    05.0
01B1:  BSF    03.5
01B2:  BCF    05.0
....................    delay_cycles(1); 
01B3:  NOP
....................    high = lcd_read_nibble(); 
01B4:  BCF    03.5
01B5:  CALL   16D
01B6:  MOVF   78,W
01B7:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
01B8:  BCF    05.0
01B9:  BSF    03.5
01BA:  BCF    05.0
....................    delay_cycles(1); 
01BB:  NOP
....................    lcd_output_enable(1); 
01BC:  BCF    03.5
01BD:  BSF    05.0
01BE:  BSF    03.5
01BF:  BCF    05.0
....................    delay_us(1); 
01C0:  NOP
....................    low = lcd_read_nibble(); 
01C1:  BCF    03.5
01C2:  CALL   16D
01C3:  MOVF   78,W
01C4:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
01C5:  BCF    05.0
01C6:  BSF    03.5
01C7:  BCF    05.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01C8:  BCF    06.4
....................    output_drive(LCD_DATA5); 
01C9:  BCF    06.5
....................    output_drive(LCD_DATA6); 
01CA:  BCF    06.6
....................    output_drive(LCD_DATA7); 
01CB:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01CC:  BCF    03.5
01CD:  SWAPF  4E,W
01CE:  MOVWF  77
01CF:  MOVLW  F0
01D0:  ANDWF  77,F
01D1:  MOVF   77,W
01D2:  IORWF  4D,W
01D3:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
016D:  CLRF   4F
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
016E:  BSF    03.5
016F:  BSF    06.4
0170:  MOVLW  00
0171:  BCF    03.5
0172:  BTFSC  06.4
0173:  MOVLW  01
0174:  IORWF  4F,F
....................    n |= input(LCD_DATA5) << 1; 
0175:  BSF    03.5
0176:  BSF    06.5
0177:  MOVLW  00
0178:  BCF    03.5
0179:  BTFSC  06.5
017A:  MOVLW  01
017B:  MOVWF  77
017C:  BCF    03.0
017D:  RLF    77,F
017E:  MOVF   77,W
017F:  IORWF  4F,F
....................    n |= input(LCD_DATA6) << 2; 
0180:  BSF    03.5
0181:  BSF    06.6
0182:  MOVLW  00
0183:  BCF    03.5
0184:  BTFSC  06.6
0185:  MOVLW  01
0186:  MOVWF  77
0187:  RLF    77,F
0188:  RLF    77,F
0189:  MOVLW  FC
018A:  ANDWF  77,F
018B:  MOVF   77,W
018C:  IORWF  4F,F
....................    n |= input(LCD_DATA7) << 3; 
018D:  BSF    03.5
018E:  BSF    06.7
018F:  MOVLW  00
0190:  BCF    03.5
0191:  BTFSC  06.7
0192:  MOVLW  01
0193:  MOVWF  77
0194:  RLF    77,F
0195:  RLF    77,F
0196:  RLF    77,F
0197:  MOVLW  F8
0198:  ANDWF  77,F
0199:  MOVF   77,W
019A:  IORWF  4F,F
....................     
....................    return(n); 
019B:  MOVF   4F,W
019C:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
019D:  RETURN
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0142:  BTFSC  4E.0
0143:  GOTO   146
0144:  BCF    06.4
0145:  GOTO   147
0146:  BSF    06.4
0147:  BSF    03.5
0148:  BCF    06.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0149:  BCF    03.5
014A:  BTFSC  4E.1
014B:  GOTO   14E
014C:  BCF    06.5
014D:  GOTO   14F
014E:  BSF    06.5
014F:  BSF    03.5
0150:  BCF    06.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0151:  BCF    03.5
0152:  BTFSC  4E.2
0153:  GOTO   156
0154:  BCF    06.6
0155:  GOTO   157
0156:  BSF    06.6
0157:  BSF    03.5
0158:  BCF    06.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0159:  BCF    03.5
015A:  BTFSC  4E.3
015B:  GOTO   15E
015C:  BCF    06.7
015D:  GOTO   15F
015E:  BSF    06.7
015F:  BSF    03.5
0160:  BCF    06.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0161:  NOP
....................    lcd_output_enable(1); 
0162:  BCF    03.5
0163:  BSF    05.0
0164:  BSF    03.5
0165:  BCF    05.0
....................    delay_us(2); 
0166:  GOTO   167
....................    lcd_output_enable(0); 
0167:  BCF    03.5
0168:  BCF    05.0
0169:  BSF    03.5
016A:  BCF    05.0
.................... } 
016B:  BCF    03.5
016C:  RETURN
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
019E:  BSF    03.5
019F:  BCF    05.0
....................    lcd_rs_tris(); 
01A0:  BCF    05.1
....................    lcd_rw_tris(); 
01A1:  BCF    05.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01A2:  BCF    03.5
01A3:  BCF    05.1
01A4:  BSF    03.5
01A5:  BCF    05.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01D4:  MOVF   78,W
01D5:  MOVWF  4D
01D6:  BTFSS  4D.7
01D7:  GOTO   1DA
01D8:  BSF    03.5
01D9:  GOTO   1A6
....................    lcd_output_rs(address); 
01DA:  MOVF   4B,F
01DB:  BTFSS  03.2
01DC:  GOTO   1DF
01DD:  BCF    05.1
01DE:  GOTO   1E0
01DF:  BSF    05.1
01E0:  BSF    03.5
01E1:  BCF    05.1
....................    delay_cycles(1); 
01E2:  NOP
....................    lcd_output_rw(0); 
01E3:  BCF    03.5
01E4:  BCF    05.2
01E5:  BSF    03.5
01E6:  BCF    05.2
....................    delay_cycles(1); 
01E7:  NOP
....................    lcd_output_enable(0); 
01E8:  BCF    03.5
01E9:  BCF    05.0
01EA:  BSF    03.5
01EB:  BCF    05.0
....................    lcd_send_nibble(n >> 4); 
01EC:  BCF    03.5
01ED:  SWAPF  4C,W
01EE:  MOVWF  4D
01EF:  MOVLW  0F
01F0:  ANDWF  4D,F
01F1:  MOVF   4D,W
01F2:  MOVWF  4E
01F3:  CALL   142
....................    lcd_send_nibble(n & 0xf); 
01F4:  MOVF   4C,W
01F5:  ANDLW  0F
01F6:  MOVWF  4D
01F7:  MOVWF  4E
01F8:  CALL   142
.................... } 
01F9:  RETURN
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01FA:  BSF    03.5
01FB:  BCF    06.4
....................    output_drive(LCD_DATA5); 
01FC:  BCF    06.5
....................    output_drive(LCD_DATA6); 
01FD:  BCF    06.6
....................    output_drive(LCD_DATA7); 
01FE:  BCF    06.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
01FF:  BCF    05.0
....................    lcd_rs_tris(); 
0200:  BCF    05.1
....................    lcd_rw_tris(); 
0201:  BCF    05.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0202:  BCF    03.5
0203:  BCF    05.1
0204:  BSF    03.5
0205:  BCF    05.1
....................    lcd_output_rw(0); 
0206:  BCF    03.5
0207:  BCF    05.2
0208:  BSF    03.5
0209:  BCF    05.2
....................    lcd_output_enable(0); 
020A:  BCF    03.5
020B:  BCF    05.0
020C:  BSF    03.5
020D:  BCF    05.0
....................      
....................    delay_ms(15); 
020E:  MOVLW  0F
020F:  BCF    03.5
0210:  MOVWF  47
0211:  CALL   12D
....................    for(i=1;i<=3;++i) 
0212:  MOVLW  01
0213:  MOVWF  3D
0214:  MOVF   3D,W
0215:  SUBLW  03
0216:  BTFSS  03.0
0217:  GOTO   220
....................    { 
....................        lcd_send_nibble(3); 
0218:  MOVLW  03
0219:  MOVWF  4E
021A:  CALL   142
....................        delay_ms(5); 
021B:  MOVLW  05
021C:  MOVWF  47
021D:  CALL   12D
....................    } 
021E:  INCF   3D,F
021F:  GOTO   214
....................     
....................    lcd_send_nibble(2); 
0220:  MOVLW  02
0221:  MOVWF  4E
0222:  CALL   142
....................    delay_ms(5); 
0223:  MOVLW  05
0224:  MOVWF  47
0225:  CALL   12D
....................    for(i=0;i<=3;++i) 
0226:  CLRF   3D
0227:  MOVF   3D,W
0228:  SUBLW  03
0229:  BTFSS  03.0
022A:  GOTO   234
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
022B:  MOVF   3D,W
022C:  CALL   004
022D:  MOVWF  3E
022E:  CLRF   4B
022F:  MOVF   3E,W
0230:  MOVWF  4C
0231:  CALL   19E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0232:  INCF   3D,F
0233:  GOTO   227
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
0234:  GOTO   3F6 (RETURN)
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................     
....................    if(y!=1) 
*
026F:  DECFSZ 48,W
0270:  GOTO   272
0271:  GOTO   275
....................       address=LCD_LINE_TWO; 
0272:  MOVLW  40
0273:  MOVWF  49
....................    else 
0274:  GOTO   276
....................       address=0; 
0275:  CLRF   49
....................       
....................    address+=x-1; 
0276:  MOVLW  01
0277:  SUBWF  47,W
0278:  ADDWF  49,F
....................    lcd_send_byte(0,0x80|address); 
0279:  MOVF   49,W
027A:  IORLW  80
027B:  MOVWF  4A
027C:  CLRF   4B
027D:  MOVF   4A,W
027E:  MOVWF  4C
027F:  CALL   19E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
0280:  RETURN
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
0281:  MOVF   46,W
0282:  XORLW  07
0283:  BTFSC  03.2
0284:  GOTO   28F
0285:  XORLW  0B
0286:  BTFSC  03.2
0287:  GOTO   294
0288:  XORLW  06
0289:  BTFSC  03.2
028A:  GOTO   29C
028B:  XORLW  02
028C:  BTFSC  03.2
028D:  GOTO   2A2
028E:  GOTO   2A7
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
028F:  MOVLW  01
0290:  MOVWF  47
0291:  MOVWF  48
0292:  CALL   26F
0293:  GOTO   2AD
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0294:  CLRF   4B
0295:  MOVLW  01
0296:  MOVWF  4C
0297:  CALL   19E
....................                      delay_ms(2); 
0298:  MOVLW  02
0299:  MOVWF  47
029A:  CALL   12D
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
029B:  GOTO   2AD
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
029C:  MOVLW  01
029D:  MOVWF  47
029E:  MOVLW  02
029F:  MOVWF  48
02A0:  CALL   26F
02A1:  GOTO   2AD
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02A2:  CLRF   4B
02A3:  MOVLW  10
02A4:  MOVWF  4C
02A5:  CALL   19E
02A6:  GOTO   2AD
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02A7:  MOVLW  01
02A8:  MOVWF  4B
02A9:  MOVF   46,W
02AA:  MOVWF  4C
02AB:  CALL   19E
02AC:  GOTO   2AD
....................      #endif 
....................    } 
.................... } 
02AD:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
....................  
.................... char tec[4],ee[5],rep,numt,inte,cl=0; 
.................... long contra,num,num1,numero[2]; 
.................... char teclado(); 
....................  
.................... void main() 
.................... { 
*
03E9:  CLRF   04
03EA:  BCF    03.7
03EB:  MOVLW  1F
03EC:  ANDWF  03,F
03ED:  BSF    03.5
03EE:  BSF    0E.3
03EF:  BCF    03.5
03F0:  CLRF   32
03F1:  MOVLW  07
03F2:  MOVWF  1F
....................    lcd_init (); 
*
03F5:  GOTO   1FA
....................    Trisb = 0b00001111; 
03F6:  MOVLW  0F
03F7:  BSF    03.5
03F8:  MOVWF  06
....................    Portb = 0; 
03F9:  BCF    03.5
03FA:  CLRF   06
....................    Trisa = 0; 
03FB:  BSF    03.5
03FC:  CLRF   05
....................    Porta = 0; 
03FD:  BCF    03.5
03FE:  CLRF   05
....................  
....................    while (true) 
....................    { 
....................       /*for (rep = 0; rep >= 4; rep++) 
....................       { 
....................          ee[rep] = read_eeprom (rep) ; 
....................       }*/ 
....................       rep=0; 
03FF:  CLRF   2F
....................       while(rep<=4) 
....................       { 
0400:  MOVF   2F,W
0401:  SUBLW  04
0402:  BTFSS  03.0
0403:  GOTO   412
....................          ee[rep]=read_eeprom(rep); 
0404:  MOVLW  2A
0405:  ADDWF  2F,W
0406:  MOVWF  04
0407:  BCF    03.7
0408:  MOVF   2F,W
0409:  BSF    03.5
040A:  MOVWF  1B
040B:  BCF    1C.7
040C:  BSF    1C.0
040D:  MOVF   1A,W
040E:  MOVWF  00
....................          //printf(lcd_putc,"\f%u",tec[rep]); 
....................          //delay_ms(500); 
....................          rep++; 
040F:  BCF    03.5
0410:  INCF   2F,F
....................       } 
0411:  GOTO   400
....................        
....................        
....................        
....................       if ((ee[0] + ee[1] + ee[2] + ee[3]) > 52) 
0412:  MOVF   2B,W
0413:  ADDWF  2A,W
0414:  ADDWF  2C,W
0415:  ADDWF  2D,W
0416:  SUBLW  34
0417:  BTFSC  03.0
0418:  GOTO   449
....................       { 
....................          for (rep = 0; rep >= 4; rep++) 
0419:  CLRF   2F
041A:  MOVF   2F,W
041B:  SUBLW  03
041C:  BTFSC  03.0
041D:  GOTO   449
....................          { 
....................             write_eeprom (rep, 0) ; 
041E:  MOVF   2F,W
041F:  BSF    03.5
0420:  MOVWF  1B
0421:  CLRF   1A
0422:  BCF    1C.7
0423:  BSF    1C.2
0424:  BCF    03.5
0425:  MOVF   0B,W
0426:  MOVWF  77
0427:  BCF    0B.7
0428:  BSF    03.5
0429:  MOVLW  55
042A:  MOVWF  1D
042B:  MOVLW  AA
042C:  MOVWF  1D
042D:  BSF    1C.1
042E:  BTFSC  1C.1
042F:  GOTO   42E
0430:  BCF    1C.2
0431:  MOVF   77,W
0432:  BCF    03.5
0433:  IORWF  0B,F
....................             for (rep = 0; rep >= 3; rep++) 
0434:  CLRF   2F
0435:  MOVF   2F,W
0436:  SUBLW  02
0437:  BTFSC  03.0
0438:  GOTO   447
....................             { 
....................                ee[rep] = read_eeprom (rep) ; 
0439:  MOVLW  2A
043A:  ADDWF  2F,W
043B:  MOVWF  04
043C:  BCF    03.7
043D:  MOVF   2F,W
043E:  BSF    03.5
043F:  MOVWF  1B
0440:  BCF    1C.7
0441:  BSF    1C.0
0442:  MOVF   1A,W
0443:  MOVWF  00
....................             } 
0444:  BCF    03.5
0445:  INCF   2F,F
0446:  GOTO   435
....................          } 
0447:  INCF   2F,F
0448:  GOTO   41A
....................       } 
....................       inicio: 
....................       cl = 0; 
0449:  CLRF   32
....................       /*for (rep = 0; rep >= 4; rep++) 
....................       { 
....................          ee[rep] = read_eeprom (rep) ; 
....................       }*/ 
....................        
....................        
....................       rep=0; 
044A:  CLRF   2F
....................       while(rep<=3) 
....................       { 
044B:  MOVF   2F,W
044C:  SUBLW  03
044D:  BTFSS  03.0
044E:  GOTO   45D
....................          ee[rep]=read_eeprom(rep); 
044F:  MOVLW  2A
0450:  ADDWF  2F,W
0451:  MOVWF  04
0452:  BCF    03.7
0453:  MOVF   2F,W
0454:  BSF    03.5
0455:  MOVWF  1B
0456:  BCF    1C.7
0457:  BSF    1C.0
0458:  MOVF   1A,W
0459:  MOVWF  00
....................          //printf(lcd_putc,"\f%u",tec[rep]); 
....................          //delay_ms(500); 
....................          rep++; 
045A:  BCF    03.5
045B:  INCF   2F,F
....................       } 
045C:  GOTO   44B
....................        
....................        
....................        
....................        
....................        
....................       contra = ee[0] * 1000 + ee[1] * 100 + ee[2] * 10 + ee[3]; 
045D:  CLRF   3E
045E:  MOVF   2A,W
045F:  MOVWF  3D
0460:  MOVLW  03
0461:  MOVWF  40
0462:  MOVLW  E8
0463:  MOVWF  3F
0464:  CALL   235
0465:  MOVF   79,W
0466:  MOVWF  3E
0467:  MOVF   78,W
0468:  MOVWF  3D
0469:  MOVF   2B,W
046A:  MOVWF  3F
046B:  MOVLW  64
046C:  MOVWF  40
046D:  CALL   24A
046E:  MOVF   78,W
046F:  ADDWF  3D,F
0470:  BTFSC  03.0
0471:  INCF   3E,F
0472:  MOVF   2C,W
0473:  MOVWF  3F
0474:  MOVLW  0A
0475:  MOVWF  40
0476:  CALL   24A
0477:  MOVF   78,W
0478:  ADDWF  3D,F
0479:  BTFSC  03.0
047A:  INCF   3E,F
047B:  MOVF   2D,W
047C:  ADDWF  3D,W
047D:  MOVWF  33
047E:  MOVF   3E,W
047F:  MOVWF  34
0480:  BTFSC  03.0
0481:  INCF   34,F
....................       //lcd_putc ("\f"); 
....................       //lcd_gotoxy (4, 1) ; 
....................       lcd_putc ("\f    Ingrese la\n"); 
0482:  CLRF   3D
0483:  MOVF   3D,W
0484:  CALL   00C
0485:  IORLW  00
0486:  BTFSC  03.2
0487:  GOTO   48C
0488:  INCF   3D,F
0489:  MOVWF  46
048A:  CALL   281
048B:  GOTO   483
....................       //lcd_gotoxy (6, 2) ; 
....................       lcd_putc ("      Clave"); 
048C:  CLRF   3D
048D:  MOVF   3D,W
048E:  CALL   021
048F:  IORLW  00
0490:  BTFSC  03.2
0491:  GOTO   496
0492:  INCF   3D,F
0493:  MOVWF  46
0494:  CALL   281
0495:  GOTO   48D
....................       delay_ms (1000); 
0496:  MOVLW  04
0497:  MOVWF  3D
0498:  MOVLW  FA
0499:  MOVWF  47
049A:  CALL   12D
049B:  DECFSZ 3D,F
049C:  GOTO   498
....................  
....................       dig: 
....................       //lcd_putc ("\f"); 
....................       //lcd_gotoxy (5, 1) ; 
....................       lcd_putc ("\f     Clave:"); 
049D:  CLRF   3D
049E:  MOVF   3D,W
049F:  CALL   031
04A0:  IORLW  00
04A1:  BTFSC  03.2
04A2:  GOTO   4A7
04A3:  INCF   3D,F
04A4:  MOVWF  46
04A5:  CALL   281
04A6:  GOTO   49E
....................       rep = 0; 
04A7:  CLRF   2F
....................  
....................       while (rep <= 3) 
....................       { 
04A8:  MOVF   2F,W
04A9:  SUBLW  03
04AA:  BTFSS  03.0
04AB:  GOTO   4F1
....................          numt = teclado (); 
04AC:  CALL   2AE
04AD:  MOVF   78,W
04AE:  MOVWF  30
....................          if (numt == '#'){numt = 20; } 
04AF:  MOVF   30,W
04B0:  SUBLW  23
04B1:  BTFSS  03.2
04B2:  GOTO   4B5
04B3:  MOVLW  14
04B4:  MOVWF  30
....................          if (numt != 20) 
04B5:  MOVF   30,W
04B6:  SUBLW  14
04B7:  BTFSC  03.2
04B8:  GOTO   4F0
....................          { 
....................             delay_ms (300); 
04B9:  MOVLW  02
04BA:  MOVWF  3D
04BB:  MOVLW  96
04BC:  MOVWF  47
04BD:  CALL   12D
04BE:  DECFSZ 3D,F
04BF:  GOTO   4BB
....................  
....................             if (numt == '*') 
04C0:  MOVF   30,W
04C1:  SUBLW  2A
04C2:  BTFSS  03.2
04C3:  GOTO   4D8
....................             { 
....................                cl = 1; 
04C4:  MOVLW  01
04C5:  MOVWF  32
....................                //lcd_putc ("\f"); 
....................                //lcd_gotoxy (1, 1) ; 
....................                lcd_putc ("\f Clave anterior:"); 
04C6:  CLRF   3D
04C7:  MOVF   3D,W
04C8:  CALL   042
04C9:  IORLW  00
04CA:  BTFSC  03.2
04CB:  GOTO   4D0
04CC:  INCF   3D,F
04CD:  MOVWF  46
04CE:  CALL   281
04CF:  GOTO   4C7
....................                delay_ms (1000); 
04D0:  MOVLW  04
04D1:  MOVWF  3D
04D2:  MOVLW  FA
04D3:  MOVWF  47
04D4:  CALL   12D
04D5:  DECFSZ 3D,F
04D6:  GOTO   4D2
....................                goto dig; 
04D7:  GOTO   49D
....................             } 
....................  
....................             tec[rep] = numt; 
04D8:  MOVLW  26
04D9:  ADDWF  2F,W
04DA:  MOVWF  04
04DB:  BCF    03.7
04DC:  MOVF   30,W
04DD:  MOVWF  00
....................             lcd_gotoxy ( (6 + rep), 2); 
04DE:  MOVLW  06
04DF:  ADDWF  2F,W
04E0:  MOVWF  3D
04E1:  MOVWF  47
04E2:  MOVLW  02
04E3:  MOVWF  48
04E4:  CALL   26F
....................             lcd_putc (" * "); 
04E5:  CLRF   3D
04E6:  MOVF   3D,W
04E7:  CALL   058
04E8:  IORLW  00
04E9:  BTFSC  03.2
04EA:  GOTO   4EF
04EB:  INCF   3D,F
04EC:  MOVWF  46
04ED:  CALL   281
04EE:  GOTO   4E6
....................             rep++; 
04EF:  INCF   2F,F
....................          } 
....................       } 
04F0:  GOTO   4A8
....................  
....................       switch (cl) 
....................       { 
04F1:  MOVF   32,W
04F2:  XORLW  01
04F3:  BTFSC  03.2
04F4:  GOTO   4FC
04F5:  XORLW  03
04F6:  BTFSC  03.2
04F7:  GOTO   552
04F8:  XORLW  01
04F9:  BTFSC  03.2
04FA:  GOTO   58D
04FB:  GOTO   61B
....................       case 1: 
....................          //goto cambio1; 
....................             numero[0] = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
04FC:  CLRF   3E
04FD:  MOVF   26,W
04FE:  MOVWF  3D
04FF:  MOVLW  03
0500:  MOVWF  40
0501:  MOVLW  E8
0502:  MOVWF  3F
0503:  CALL   235
0504:  MOVF   79,W
0505:  MOVWF  3E
0506:  MOVF   78,W
0507:  MOVWF  3D
0508:  MOVF   27,W
0509:  MOVWF  3F
050A:  MOVLW  64
050B:  MOVWF  40
050C:  CALL   24A
050D:  MOVF   78,W
050E:  ADDWF  3D,F
050F:  BTFSC  03.0
0510:  INCF   3E,F
0511:  MOVF   28,W
0512:  MOVWF  3F
0513:  MOVLW  0A
0514:  MOVWF  40
0515:  CALL   24A
0516:  MOVF   78,W
0517:  ADDWF  3D,F
0518:  BTFSC  03.0
0519:  INCF   3E,F
051A:  MOVF   29,W
051B:  ADDWF  3D,W
051C:  MOVWF  39
051D:  MOVF   3E,W
051E:  MOVWF  3A
051F:  BTFSC  03.0
0520:  INCF   3A,F
....................     
....................             if (contra == (numero[0])) 
0521:  MOVF   39,W
0522:  SUBWF  33,W
0523:  BTFSS  03.2
0524:  GOTO   53E
0525:  MOVF   3A,W
0526:  SUBWF  34,W
0527:  BTFSS  03.2
0528:  GOTO   53E
....................             { 
....................                cl = 2; 
0529:  MOVLW  02
052A:  MOVWF  32
....................                lcd_putc ("\f Nueva clave:"); 
052B:  CLRF   3D
052C:  MOVF   3D,W
052D:  CALL   060
052E:  IORLW  00
052F:  BTFSC  03.2
0530:  GOTO   535
0531:  INCF   3D,F
0532:  MOVWF  46
0533:  CALL   281
0534:  GOTO   52C
....................                delay_ms (1000); 
0535:  MOVLW  04
0536:  MOVWF  3D
0537:  MOVLW  FA
0538:  MOVWF  47
0539:  CALL   12D
053A:  DECFSZ 3D,F
053B:  GOTO   537
....................                goto dig; 
053C:  GOTO   49D
....................             } 
....................     
....................             else 
053D:  GOTO   550
....................             { 
....................                //lcd_putc ("\f"); 
....................                //lcd_gotoxy (1, 1) ; 
....................                printf (lcd_putc, "\fClave incorrecta") ; 
053E:  CLRF   3D
053F:  MOVF   3D,W
0540:  CALL   073
0541:  INCF   3D,F
0542:  MOVWF  77
0543:  MOVWF  46
0544:  CALL   281
0545:  MOVLW  11
0546:  SUBWF  3D,W
0547:  BTFSS  03.2
0548:  GOTO   53F
....................                delay_ms (1000); 
0549:  MOVLW  04
054A:  MOVWF  3D
054B:  MOVLW  FA
054C:  MOVWF  47
054D:  CALL   12D
054E:  DECFSZ 3D,F
054F:  GOTO   54B
....................             } 
....................     
....................             goto inicio; 
0550:  GOTO   449
....................          break; 
0551:  GOTO   61D
....................          case 2: 
....................          //goto cambio2; 
....................             num = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
0552:  CLRF   3E
0553:  MOVF   26,W
0554:  MOVWF  3D
0555:  MOVLW  03
0556:  MOVWF  40
0557:  MOVLW  E8
0558:  MOVWF  3F
0559:  CALL   235
055A:  MOVF   79,W
055B:  MOVWF  3E
055C:  MOVF   78,W
055D:  MOVWF  3D
055E:  MOVF   27,W
055F:  MOVWF  3F
0560:  MOVLW  64
0561:  MOVWF  40
0562:  CALL   24A
0563:  MOVF   78,W
0564:  ADDWF  3D,F
0565:  BTFSC  03.0
0566:  INCF   3E,F
0567:  MOVF   28,W
0568:  MOVWF  3F
0569:  MOVLW  0A
056A:  MOVWF  40
056B:  CALL   24A
056C:  MOVF   78,W
056D:  ADDWF  3D,F
056E:  BTFSC  03.0
056F:  INCF   3E,F
0570:  MOVF   29,W
0571:  ADDWF  3D,W
0572:  MOVWF  35
0573:  MOVF   3E,W
0574:  MOVWF  36
0575:  BTFSC  03.0
0576:  INCF   36,F
....................             cl = 3; 
0577:  MOVLW  03
0578:  MOVWF  32
....................             //lcd_putc ("\f"); 
....................             //lcd_gotoxy (1, 1) ; 
....................             printf (lcd_putc, "\fRepita la clave:") ; 
0579:  CLRF   3D
057A:  MOVF   3D,W
057B:  CALL   089
057C:  INCF   3D,F
057D:  MOVWF  77
057E:  MOVWF  46
057F:  CALL   281
0580:  MOVLW  11
0581:  SUBWF  3D,W
0582:  BTFSS  03.2
0583:  GOTO   57A
....................             delay_ms (1000); 
0584:  MOVLW  04
0585:  MOVWF  3D
0586:  MOVLW  FA
0587:  MOVWF  47
0588:  CALL   12D
0589:  DECFSZ 3D,F
058A:  GOTO   586
....................             goto dig; 
058B:  GOTO   49D
....................          break; 
058C:  GOTO   61D
....................  
....................          case 3: 
....................          //goto cambio3; 
....................             num1 = (tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]); 
058D:  CLRF   3E
058E:  MOVF   26,W
058F:  MOVWF  3D
0590:  MOVLW  03
0591:  MOVWF  40
0592:  MOVLW  E8
0593:  MOVWF  3F
0594:  CALL   235
0595:  MOVF   79,W
0596:  MOVWF  3E
0597:  MOVF   78,W
0598:  MOVWF  3D
0599:  MOVF   27,W
059A:  MOVWF  3F
059B:  MOVLW  64
059C:  MOVWF  40
059D:  CALL   24A
059E:  MOVF   78,W
059F:  ADDWF  3D,F
05A0:  BTFSC  03.0
05A1:  INCF   3E,F
05A2:  MOVF   28,W
05A3:  MOVWF  3F
05A4:  MOVLW  0A
05A5:  MOVWF  40
05A6:  CALL   24A
05A7:  MOVF   78,W
05A8:  ADDWF  3D,F
05A9:  BTFSC  03.0
05AA:  INCF   3E,F
05AB:  MOVF   29,W
05AC:  ADDWF  3D,W
05AD:  MOVWF  37
05AE:  MOVF   3E,W
05AF:  MOVWF  38
05B0:  BTFSC  03.0
05B1:  INCF   38,F
....................     
....................             if (num == num1) 
05B2:  MOVF   37,W
05B3:  SUBWF  35,W
05B4:  BTFSS  03.2
05B5:  GOTO   608
05B6:  MOVF   38,W
05B7:  SUBWF  36,W
05B8:  BTFSS  03.2
05B9:  GOTO   608
....................             { 
....................                rep=0; 
05BA:  CLRF   2F
....................                while(rep<=3) 
....................                { 
05BB:  MOVF   2F,W
05BC:  SUBLW  03
05BD:  BTFSS  03.0
05BE:  GOTO   5F5
....................                   write_eeprom (rep, tec[rep]); 
05BF:  MOVLW  26
05C0:  ADDWF  2F,W
05C1:  MOVWF  04
05C2:  BCF    03.7
05C3:  MOVF   00,W
05C4:  MOVWF  3D
05C5:  MOVF   2F,W
05C6:  BSF    03.5
05C7:  MOVWF  1B
05C8:  BCF    03.5
05C9:  MOVF   3D,W
05CA:  BSF    03.5
05CB:  MOVWF  1A
05CC:  BCF    1C.7
05CD:  BSF    1C.2
05CE:  BCF    03.5
05CF:  MOVF   0B,W
05D0:  MOVWF  77
05D1:  BCF    0B.7
05D2:  BSF    03.5
05D3:  MOVLW  55
05D4:  MOVWF  1D
05D5:  MOVLW  AA
05D6:  MOVWF  1D
05D7:  BSF    1C.1
05D8:  BTFSC  1C.1
05D9:  GOTO   5D8
05DA:  BCF    1C.2
05DB:  MOVF   77,W
05DC:  BCF    03.5
05DD:  IORWF  0B,F
....................                   printf(lcd_putc,"\f%u",tec[rep]); 
05DE:  MOVLW  26
05DF:  ADDWF  2F,W
05E0:  MOVWF  04
05E1:  BCF    03.7
05E2:  MOVF   00,W
05E3:  MOVWF  3D
05E4:  MOVLW  0C
05E5:  MOVWF  46
05E6:  CALL   281
05E7:  MOVF   3D,W
05E8:  MOVWF  3E
05E9:  MOVLW  1B
05EA:  MOVWF  3F
05EB:  GOTO   351
....................                   delay_ms(500); 
05EC:  MOVLW  02
05ED:  MOVWF  3D
05EE:  MOVLW  FA
05EF:  MOVWF  47
05F0:  CALL   12D
05F1:  DECFSZ 3D,F
05F2:  GOTO   5EE
....................                   rep++; 
05F3:  INCF   2F,F
....................                } 
05F4:  GOTO   5BB
....................                //lcd_putc ("\f"); 
....................                //lcd_gotoxy (1, 1) ; 
....................                lcd_putc ("\fClave cambiada"); 
05F5:  CLRF   3D
05F6:  MOVF   3D,W
05F7:  CALL   09F
05F8:  IORLW  00
05F9:  BTFSC  03.2
05FA:  GOTO   5FF
05FB:  INCF   3D,F
05FC:  MOVWF  46
05FD:  CALL   281
05FE:  GOTO   5F6
....................                delay_ms (1000); 
05FF:  MOVLW  04
0600:  MOVWF  3D
0601:  MOVLW  FA
0602:  MOVWF  47
0603:  CALL   12D
0604:  DECFSZ 3D,F
0605:  GOTO   601
....................                goto inicio; 
0606:  GOTO   449
....................             } 
....................     
....................             else 
0607:  GOTO   619
....................             { 
....................                //lcd_putc ("\f"); 
....................                //lcd_gotoxy (2, 1) ; 
....................                lcd_putc ("\f NO CAMBIADA"); 
0608:  CLRF   3D
0609:  MOVF   3D,W
060A:  CALL   0B3
060B:  IORLW  00
060C:  BTFSC  03.2
060D:  GOTO   612
060E:  INCF   3D,F
060F:  MOVWF  46
0610:  CALL   281
0611:  GOTO   609
....................                delay_ms (1000); 
0612:  MOVLW  04
0613:  MOVWF  3D
0614:  MOVLW  FA
0615:  MOVWF  47
0616:  CALL   12D
0617:  DECFSZ 3D,F
0618:  GOTO   614
....................             } 
....................     
....................             goto inicio; 
0619:  GOTO   449
....................          break; 
061A:  GOTO   61D
....................          default: 
....................             goto compara; 
061B:  GOTO   61D
....................          break; 
061C:  GOTO   61D
....................       } 
....................  
....................       compara: 
....................       numero[0] = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
061D:  CLRF   3E
061E:  MOVF   26,W
061F:  MOVWF  3D
0620:  MOVLW  03
0621:  MOVWF  40
0622:  MOVLW  E8
0623:  MOVWF  3F
0624:  CALL   235
0625:  MOVF   79,W
0626:  MOVWF  3E
0627:  MOVF   78,W
0628:  MOVWF  3D
0629:  MOVF   27,W
062A:  MOVWF  3F
062B:  MOVLW  64
062C:  MOVWF  40
062D:  CALL   24A
062E:  MOVF   78,W
062F:  ADDWF  3D,F
0630:  BTFSC  03.0
0631:  INCF   3E,F
0632:  MOVF   28,W
0633:  MOVWF  3F
0634:  MOVLW  0A
0635:  MOVWF  40
0636:  CALL   24A
0637:  MOVF   78,W
0638:  ADDWF  3D,F
0639:  BTFSC  03.0
063A:  INCF   3E,F
063B:  MOVF   29,W
063C:  ADDWF  3D,W
063D:  MOVWF  39
063E:  MOVF   3E,W
063F:  MOVWF  3A
0640:  BTFSC  03.0
0641:  INCF   3A,F
....................  
....................       if (contra == (numero[0])) 
0642:  MOVF   39,W
0643:  SUBWF  33,W
0644:  BTFSS  03.2
0645:  GOTO   69D
0646:  MOVF   3A,W
0647:  SUBWF  34,W
0648:  BTFSS  03.2
0649:  GOTO   69D
....................       { 
....................          inte = 0; 
064A:  CLRF   31
....................          write_eeprom (4, 1) ; 
064B:  MOVLW  04
064C:  BSF    03.5
064D:  MOVWF  1B
064E:  MOVLW  01
064F:  MOVWF  1A
0650:  BCF    1C.7
0651:  BSF    1C.2
0652:  BCF    03.5
0653:  MOVF   0B,W
0654:  MOVWF  77
0655:  BCF    0B.7
0656:  BSF    03.5
0657:  MOVLW  55
0658:  MOVWF  1D
0659:  MOVLW  AA
065A:  MOVWF  1D
065B:  BSF    1C.1
065C:  BTFSC  1C.1
065D:  GOTO   65C
065E:  BCF    1C.2
065F:  MOVF   77,W
0660:  BCF    03.5
0661:  IORWF  0B,F
....................          //lcd_putc ("\f"); 
....................          //lcd_gotoxy (2, 1) ; 
....................          lcd_putc ("\f  Clave correcta\n"); 
0662:  CLRF   3D
0663:  MOVF   3D,W
0664:  CALL   0C5
0665:  IORLW  00
0666:  BTFSC  03.2
0667:  GOTO   66C
0668:  INCF   3D,F
0669:  MOVWF  46
066A:  CALL   281
066B:  GOTO   663
....................          //lcd_gotoxy (3, 2) ; 
....................          lcd_putc ("   Matriz 8x8"); 
066C:  CLRF   3D
066D:  MOVF   3D,W
066E:  CALL   0DC
066F:  IORLW  00
0670:  BTFSC  03.2
0671:  GOTO   676
0672:  INCF   3D,F
0673:  MOVWF  46
0674:  CALL   281
0675:  GOTO   66D
....................          output_high(pin_a3); 
0676:  BSF    03.5
0677:  BCF    05.3
0678:  BCF    03.5
0679:  BSF    05.3
....................  
....................          do 
....................          { 
....................             numt = teclado (); 
067A:  CALL   2AE
067B:  MOVF   78,W
067C:  MOVWF  30
....................          } 
....................          while (numt < 21) ; 
067D:  MOVF   30,W
067E:  SUBLW  14
067F:  BTFSC  03.0
0680:  GOTO   67A
....................          output_low(pin_a3); 
0681:  BSF    03.5
0682:  BCF    05.3
0683:  BCF    03.5
0684:  BCF    05.3
....................          write_eeprom (4, 0) ; 
0685:  MOVLW  04
0686:  BSF    03.5
0687:  MOVWF  1B
0688:  CLRF   1A
0689:  BCF    1C.7
068A:  BSF    1C.2
068B:  BCF    03.5
068C:  MOVF   0B,W
068D:  MOVWF  77
068E:  BCF    0B.7
068F:  BSF    03.5
0690:  MOVLW  55
0691:  MOVWF  1D
0692:  MOVLW  AA
0693:  MOVWF  1D
0694:  BSF    1C.1
0695:  BTFSC  1C.1
0696:  GOTO   695
0697:  BCF    1C.2
0698:  MOVF   77,W
0699:  BCF    03.5
069A:  IORWF  0B,F
....................          goto inicio; 
069B:  GOTO   449
....................       } 
....................  
....................       else 
069C:  GOTO   703
....................       { 
....................          inte++; 
069D:  INCF   31,F
....................          //lcd_putc ("\f"); 
....................          //lcd_gotoxy (1, 1) ; 
....................          lcd_putc ("\fClave incorrecta"); 
069E:  CLRF   3D
069F:  MOVF   3D,W
06A0:  CALL   073
06A1:  IORLW  00
06A2:  BTFSC  03.2
06A3:  GOTO   6A8
06A4:  INCF   3D,F
06A5:  MOVWF  46
06A6:  CALL   281
06A7:  GOTO   69F
....................          delay_ms (1000); 
06A8:  MOVLW  04
06A9:  MOVWF  3D
06AA:  MOVLW  FA
06AB:  MOVWF  47
06AC:  CALL   12D
06AD:  DECFSZ 3D,F
06AE:  GOTO   6AA
....................  
....................          if (inte >= 5) 
06AF:  MOVF   31,W
06B0:  SUBLW  04
06B1:  BTFSC  03.0
06B2:  GOTO   703
....................          { 
....................             //lcd_putc ("\f"); 
....................             //lcd_gotoxy (3, 1) ; 
....................             lcd_putc ("\f   Bloqueado\n"); 
06B3:  CLRF   3D
06B4:  MOVF   3D,W
06B5:  CALL   0EE
06B6:  IORLW  00
06B7:  BTFSC  03.2
06B8:  GOTO   6BD
06B9:  INCF   3D,F
06BA:  MOVWF  46
06BB:  CALL   281
06BC:  GOTO   6B4
....................             //lcd_gotoxy (2, 2) ; 
....................             lcd_putc ("  espera 5min"); 
06BD:  CLRF   3D
06BE:  MOVF   3D,W
06BF:  CALL   104
06C0:  IORLW  00
06C1:  BTFSC  03.2
06C2:  GOTO   6C7
06C3:  INCF   3D,F
06C4:  MOVWF  46
06C5:  CALL   281
06C6:  GOTO   6BE
....................             delay_ms (999); 
06C7:  MOVLW  09
06C8:  MOVWF  3D
06C9:  MOVLW  6F
06CA:  MOVWF  47
06CB:  CALL   12D
06CC:  DECFSZ 3D,F
06CD:  GOTO   6C9
....................             for (num = 301; num > 0; num--) 
06CE:  MOVLW  01
06CF:  MOVWF  36
06D0:  MOVLW  2D
06D1:  MOVWF  35
06D2:  MOVF   35,F
06D3:  BTFSS  03.2
06D4:  GOTO   6D8
06D5:  MOVF   36,F
06D6:  BTFSC  03.2
06D7:  GOTO   702
....................             { 
....................                delay_ms (999); 
06D8:  MOVLW  09
06D9:  MOVWF  3D
06DA:  MOVLW  6F
06DB:  MOVWF  47
06DC:  CALL   12D
06DD:  DECFSZ 3D,F
06DE:  GOTO   6DA
....................                //lcd_putc ("\f"); 
....................                //lcd_gotoxy (1,1) ; 
....................                printf(lcd_putc,"\fSegundos= %Lu    ",num); 
06DF:  CLRF   3D
06E0:  MOVF   3D,W
06E1:  CALL   116
06E2:  INCF   3D,F
06E3:  MOVWF  77
06E4:  MOVWF  46
06E5:  CALL   281
06E6:  MOVLW  0B
06E7:  SUBWF  3D,W
06E8:  BTFSS  03.2
06E9:  GOTO   6E0
06EA:  MOVLW  10
06EB:  MOVWF  04
06EC:  MOVF   36,W
06ED:  MOVWF  3E
06EE:  MOVF   35,W
06EF:  MOVWF  3D
06F0:  GOTO   386
06F1:  MOVLW  0E
06F2:  MOVWF  3D
06F3:  MOVF   3D,W
06F4:  CALL   116
06F5:  INCF   3D,F
06F6:  MOVWF  77
06F7:  MOVWF  46
06F8:  CALL   281
06F9:  MOVLW  12
06FA:  SUBWF  3D,W
06FB:  BTFSS  03.2
06FC:  GOTO   6F3
....................             } 
06FD:  MOVF   35,W
06FE:  BTFSC  03.2
06FF:  DECF   36,F
0700:  DECF   35,F
0701:  GOTO   6D2
....................  
....................             inte = 0; 
0702:  CLRF   31
....................          } 
....................  
....................          //goto inicio; 
....................       } 
....................  
....................       goto inicio; 
0703:  GOTO   449
....................  
....................       /*cambio: 
....................       cl = 1; 
....................       lcd_putc ("\f"); 
....................       lcd_gotoxy (1, 1) ; 
....................       lcd_putc ("Clave anterior:"); 
....................       delay_ms (1000); 
....................       goto dig; 
....................  
....................       cambio1: 
....................       numero[0] = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
....................  
....................       if (contra == numero[0]) 
....................       { 
....................          cl = 2; 
....................          lcd_putc ("\f"); 
....................          lcd_gotoxy (2, 1) ; 
....................          lcd_putc ("Nueva clave:"); 
....................          delay_ms (1000); 
....................          goto dig; 
....................       } 
....................  
....................       lcd_putc ("\f"); 
....................       lcd_gotoxy (1, 1) ; 
....................       printf (lcd_putc, "Clave incorrecta") ; 
....................       delay_ms (1000); 
....................       goto inicio; 
....................  
....................       cambio2: 
....................       numero[0] = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
....................       cl = 3; 
....................       lcd_putc ("\f"); 
....................       lcd_gotoxy (1, 1) ; 
....................       printf (lcd_putc, "Repita la clave:") ; 
....................       delay_ms (1000); 
....................       goto dig; 
....................  
....................       cambio3: 
....................       numero[1] = tec[0] * 1000 + tec[1] * 100 + tec[2] * 10 + tec[3]; 
....................  
....................       if (numero[0] == numero[1]) 
....................       { 
....................          for (rep = 0; rep >= 3; rep++) 
....................          { 
....................             write_eeprom (rep, tec[rep]) ; 
....................          } 
....................  
....................          lcd_putc ("\f"); 
....................          lcd_gotoxy (1, 1) ; 
....................          lcd_putc ("Clave cambiada"); 
....................          delay_ms (1000); 
....................          goto inicio; 
....................       } 
....................  
....................       else 
....................       { 
....................          lcd_putc ("\f"); 
....................          lcd_gotoxy (2, 1) ; 
....................          lcd_putc ("NO CAMBIADA"); 
....................          delay_ms (1000); 
....................       } 
....................  
....................       goto inicio; */ 
....................    } 
0704:  GOTO   3FF
.................... } 
....................  
.................... char teclado() 
.................... { 
0705:  SLEEP
....................    delay_ms (100); 
*
02AE:  MOVLW  64
02AF:  MOVWF  47
02B0:  CALL   12D
....................    Portb = 16; 
02B1:  MOVLW  10
02B2:  MOVWF  06
....................    if (input (pin_b0) == 1){return (7) ; } 
02B3:  BSF    03.5
02B4:  BSF    06.0
02B5:  BCF    03.5
02B6:  BTFSS  06.0
02B7:  GOTO   2BB
02B8:  MOVLW  07
02B9:  MOVWF  78
02BA:  GOTO   33B
....................    if (input (pin_b1) == 1){return (8) ; } 
02BB:  BSF    03.5
02BC:  BSF    06.1
02BD:  BCF    03.5
02BE:  BTFSS  06.1
02BF:  GOTO   2C3
02C0:  MOVLW  08
02C1:  MOVWF  78
02C2:  GOTO   33B
....................    if (input (PIN_b2) == 1){return (9) ; } 
02C3:  BSF    03.5
02C4:  BSF    06.2
02C5:  BCF    03.5
02C6:  BTFSS  06.2
02C7:  GOTO   2CB
02C8:  MOVLW  09
02C9:  MOVWF  78
02CA:  GOTO   33B
....................    if (input (pin_b3) == 1){return (0xA); } 
02CB:  BSF    03.5
02CC:  BSF    06.3
02CD:  BCF    03.5
02CE:  BTFSS  06.3
02CF:  GOTO   2D3
02D0:  MOVLW  0A
02D1:  MOVWF  78
02D2:  GOTO   33B
....................    Portb = 32; 
02D3:  MOVLW  20
02D4:  MOVWF  06
....................    if (input (pin_b0) == 1){return (4) ; } 
02D5:  BSF    03.5
02D6:  BSF    06.0
02D7:  BCF    03.5
02D8:  BTFSS  06.0
02D9:  GOTO   2DD
02DA:  MOVLW  04
02DB:  MOVWF  78
02DC:  GOTO   33B
....................    if (input (pin_b1) == 1){return (5) ; } 
02DD:  BSF    03.5
02DE:  BSF    06.1
02DF:  BCF    03.5
02E0:  BTFSS  06.1
02E1:  GOTO   2E5
02E2:  MOVLW  05
02E3:  MOVWF  78
02E4:  GOTO   33B
....................    if (input (PIN_b2) == 1){return (6) ; } 
02E5:  BSF    03.5
02E6:  BSF    06.2
02E7:  BCF    03.5
02E8:  BTFSS  06.2
02E9:  GOTO   2ED
02EA:  MOVLW  06
02EB:  MOVWF  78
02EC:  GOTO   33B
....................    if (input (pin_b3) == 1){return (0xB); } 
02ED:  BSF    03.5
02EE:  BSF    06.3
02EF:  BCF    03.5
02F0:  BTFSS  06.3
02F1:  GOTO   2F5
02F2:  MOVLW  0B
02F3:  MOVWF  78
02F4:  GOTO   33B
....................    Portb = 64; 
02F5:  MOVLW  40
02F6:  MOVWF  06
....................    if (input (pin_b0) == 1){return (1) ; } 
02F7:  BSF    03.5
02F8:  BSF    06.0
02F9:  BCF    03.5
02FA:  BTFSS  06.0
02FB:  GOTO   2FF
02FC:  MOVLW  01
02FD:  MOVWF  78
02FE:  GOTO   33B
....................    if (input (pin_b1) == 1){return (2) ; } 
02FF:  BSF    03.5
0300:  BSF    06.1
0301:  BCF    03.5
0302:  BTFSS  06.1
0303:  GOTO   307
0304:  MOVLW  02
0305:  MOVWF  78
0306:  GOTO   33B
....................    if (input (PIN_b2) == 1){return (3) ; } 
0307:  BSF    03.5
0308:  BSF    06.2
0309:  BCF    03.5
030A:  BTFSS  06.2
030B:  GOTO   30F
030C:  MOVLW  03
030D:  MOVWF  78
030E:  GOTO   33B
....................    if (input (pin_b3) == 1){return (0xC); } 
030F:  BSF    03.5
0310:  BSF    06.3
0311:  BCF    03.5
0312:  BTFSS  06.3
0313:  GOTO   317
0314:  MOVLW  0C
0315:  MOVWF  78
0316:  GOTO   33B
....................    Portb = 128; 
0317:  MOVLW  80
0318:  MOVWF  06
....................    if (input (pin_b0) == 1){return ('*'); } 
0319:  BSF    03.5
031A:  BSF    06.0
031B:  BCF    03.5
031C:  BTFSS  06.0
031D:  GOTO   321
031E:  MOVLW  2A
031F:  MOVWF  78
0320:  GOTO   33B
....................    if (input (pin_b1) == 1){return (0) ; } 
0321:  BSF    03.5
0322:  BSF    06.1
0323:  BCF    03.5
0324:  BTFSS  06.1
0325:  GOTO   329
0326:  MOVLW  00
0327:  MOVWF  78
0328:  GOTO   33B
....................    if (input (pin_b2) == 1){return ('#'); } 
0329:  BSF    03.5
032A:  BSF    06.2
032B:  BCF    03.5
032C:  BTFSS  06.2
032D:  GOTO   331
032E:  MOVLW  23
032F:  MOVWF  78
0330:  GOTO   33B
....................    if (input (pin_b3) == 1){return (0xD); } 
0331:  BSF    03.5
0332:  BSF    06.3
0333:  BCF    03.5
0334:  BTFSS  06.3
0335:  GOTO   339
0336:  MOVLW  0D
0337:  MOVWF  78
0338:  GOTO   33B
....................     
....................    return (20); 
0339:  MOVLW  14
033A:  MOVWF  78
.................... } 
033B:  RETURN
....................  

Configuration Fuses:
   Word  1: 3F19   NOWDT NOPUT INTRC NOMCLR NOBROWNOUT NOLVP NOCPD NOPROTECT
