CCS PCM C Compiler, Version 5.007, 59972               24-sep.-16 14:58

               Filename:   C:\Users\ivan-\Documents\MEGA\Electronica\Microcontroladores\PIC\Pic C\16f677\Cerradura electronica\Cerradura.lst

               ROM used:   1650 words (81%)
                           Largest free fragment is 398
               RAM used:   51 (40%) at main() level
                           75 (59%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   463
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  25
0008:  MOVF   7F,W
0009:  MOVWF  24
000A:  MOVF   0A,W
000B:  MOVWF  2B
000C:  CLRF   0A
000D:  SWAPF  24,F
000E:  MOVF   04,W
000F:  MOVWF  26
0010:  MOVF   20,W
0011:  MOVWF  27
0012:  MOVF   21,W
0013:  MOVWF  28
0014:  MOVF   22,W
0015:  MOVWF  29
0016:  MOVF   23,W
0017:  MOVWF  2A
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.4
001B:  GOTO   01E
001C:  BTFSC  0B.1
001D:  GOTO   1AC
001E:  BTFSS  0B.5
001F:  GOTO   022
0020:  BTFSC  0B.2
0021:  GOTO   1BA
0022:  MOVF   26,W
0023:  MOVWF  04
0024:  MOVF   27,W
0025:  MOVWF  20
0026:  MOVF   28,W
0027:  MOVWF  21
0028:  MOVF   29,W
0029:  MOVWF  22
002A:  MOVF   2A,W
002B:  MOVWF  23
002C:  MOVF   2B,W
002D:  MOVWF  0A
002E:  SWAPF  25,W
002F:  MOVWF  03
0030:  SWAPF  7F,F
0031:  SWAPF  7F,W
0032:  RETFIE
.................... #include <16f677.h> 
.................... //////// Standard Header file for the PIC16F677 device //////////////// 
.................... #device PIC16F677 
0033:  BCF    0A.0
0034:  BCF    0A.1
0035:  BCF    0A.2
0036:  ADDWF  02,F
0037:  RETLW  28
0038:  RETLW  0C
0039:  RETLW  01
003A:  RETLW  06
003B:  BCF    0A.0
003C:  BCF    0A.1
003D:  BCF    0A.2
003E:  ADDWF  02,F
003F:  RETLW  31
0040:  RETLW  34
0041:  RETLW  37
0042:  RETLW  2A
0043:  RETLW  32
0044:  RETLW  35
0045:  RETLW  38
0046:  RETLW  30
0047:  RETLW  33
0048:  RETLW  36
0049:  RETLW  39
004A:  RETLW  23
004B:  RETLW  41
004C:  RETLW  42
004D:  RETLW  43
004E:  RETLW  44
004F:  BCF    0A.0
0050:  BCF    0A.1
0051:  BCF    0A.2
0052:  ADDWF  02,F
0053:  RETLW  30
0054:  RETLW  41
0055:  RETLW  42
0056:  RETLW  43
0057:  RETLW  44
0058:  RETLW  32
0059:  RETLW  38
005A:  RETLW  38
005B:  RETLW  32
005C:  RETLW  33
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  0C
0063:  RETLW  20
0064:  RETLW  20
0065:  RETLW  20
0066:  RETLW  49
0067:  RETLW  6E
0068:  RETLW  74
0069:  RETLW  72
006A:  RETLW  6F
006B:  RETLW  64
006C:  RETLW  75
006D:  RETLW  63
006E:  RETLW  65
006F:  RETLW  0A
0070:  RETLW  20
0071:  RETLW  20
0072:  RETLW  20
0073:  RETLW  6C
0074:  RETLW  61
0075:  RETLW  20
0076:  RETLW  43
0077:  RETLW  6C
0078:  RETLW  61
0079:  RETLW  76
007A:  RETLW  65
007B:  RETLW  00
007C:  BCF    0A.0
007D:  BCF    0A.1
007E:  BCF    0A.2
007F:  ADDWF  02,F
0080:  RETLW  0C
0081:  RETLW  20
0082:  RETLW  20
0083:  RETLW  20
0084:  RETLW  41
0085:  RETLW  62
0086:  RETLW  69
0087:  RETLW  65
0088:  RETLW  72
0089:  RETLW  74
008A:  RETLW  6F
008B:  RETLW  00
008C:  BCF    0A.0
008D:  BCF    0A.1
008E:  BCF    0A.2
008F:  ADDWF  02,F
0090:  RETLW  0C
0091:  RETLW  20
0092:  RETLW  20
0093:  RETLW  20
0094:  RETLW  43
0095:  RETLW  6C
0096:  RETLW  61
0097:  RETLW  76
0098:  RETLW  65
0099:  RETLW  0A
009A:  RETLW  20
009B:  RETLW  20
009C:  RETLW  49
009D:  RETLW  6E
009E:  RETLW  63
009F:  RETLW  6F
00A0:  RETLW  72
00A1:  RETLW  72
00A2:  RETLW  65
00A3:  RETLW  63
00A4:  RETLW  74
00A5:  RETLW  61
00A6:  RETLW  00
00A7:  BCF    0A.0
00A8:  BCF    0A.1
00A9:  BCF    0A.2
00AA:  ADDWF  02,F
00AB:  RETLW  0C
00AC:  RETLW  20
00AD:  RETLW  20
00AE:  RETLW  20
00AF:  RETLW  42
00B0:  RETLW  6C
00B1:  RETLW  6F
00B2:  RETLW  71
00B3:  RETLW  75
00B4:  RETLW  65
00B5:  RETLW  61
00B6:  RETLW  64
00B7:  RETLW  6F
00B8:  RETLW  0A
00B9:  RETLW  20
00BA:  RETLW  65
00BB:  RETLW  73
00BC:  RETLW  70
00BD:  RETLW  65
00BE:  RETLW  72
00BF:  RETLW  61
00C0:  RETLW  20
00C1:  RETLW  25
00C2:  RETLW  4C
00C3:  RETLW  75
00C4:  RETLW  20
00C5:  RETLW  73
00C6:  RETLW  65
00C7:  RETLW  67
00C8:  RETLW  00
00C9:  BCF    0A.0
00CA:  BCF    0A.1
00CB:  BCF    0A.2
00CC:  ADDWF  02,F
00CD:  RETLW  0C
00CE:  RETLW  20
00CF:  RETLW  49
00D0:  RETLW  6E
00D1:  RETLW  74
00D2:  RETLW  72
00D3:  RETLW  6F
00D4:  RETLW  64
00D5:  RETLW  75
00D6:  RETLW  63
00D7:  RETLW  65
00D8:  RETLW  20
00D9:  RETLW  75
00DA:  RETLW  6E
00DB:  RETLW  61
00DC:  RETLW  0A
00DD:  RETLW  20
00DE:  RETLW  20
00DF:  RETLW  6E
00E0:  RETLW  75
00E1:  RETLW  65
00E2:  RETLW  76
00E3:  RETLW  61
00E4:  RETLW  20
00E5:  RETLW  63
00E6:  RETLW  6C
00E7:  RETLW  61
00E8:  RETLW  76
00E9:  RETLW  65
00EA:  RETLW  00
00EB:  BCF    0A.0
00EC:  BCF    0A.1
00ED:  BCF    0A.2
00EE:  ADDLW  F2
00EF:  BTFSC  03.0
00F0:  INCF   0A,F
00F1:  MOVWF  02
00F2:  RETLW  0C
00F3:  RETLW  20
00F4:  RETLW  20
00F5:  RETLW  20
00F6:  RETLW  56
00F7:  RETLW  75
00F8:  RETLW  65
00F9:  RETLW  6C
00FA:  RETLW  76
00FB:  RETLW  65
00FC:  RETLW  6C
00FD:  RETLW  61
00FE:  RETLW  20
00FF:  RETLW  61
0100:  RETLW  0A
0101:  RETLW  20
0102:  RETLW  20
0103:  RETLW  20
0104:  RETLW  69
0105:  RETLW  6E
0106:  RETLW  74
0107:  RETLW  72
0108:  RETLW  6F
0109:  RETLW  64
010A:  RETLW  75
010B:  RETLW  63
010C:  RETLW  69
010D:  RETLW  72
010E:  RETLW  00
010F:  BSF    0A.0
0110:  BCF    0A.1
0111:  BCF    0A.2
0112:  ADDWF  02,F
0113:  RETLW  0C
0114:  RETLW  20
0115:  RETLW  20
0116:  RETLW  4C
0117:  RETLW  61
0118:  RETLW  20
0119:  RETLW  63
011A:  RETLW  6C
011B:  RETLW  61
011C:  RETLW  76
011D:  RETLW  65
011E:  RETLW  20
011F:  RETLW  68
0120:  RETLW  61
0121:  RETLW  0A
0122:  RETLW  20
0123:  RETLW  73
0124:  RETLW  69
0125:  RETLW  64
0126:  RETLW  6F
0127:  RETLW  20
0128:  RETLW  63
0129:  RETLW  61
012A:  RETLW  6D
012B:  RETLW  62
012C:  RETLW  69
012D:  RETLW  61
012E:  RETLW  64
012F:  RETLW  61
0130:  RETLW  00
0131:  BSF    0A.0
0132:  BCF    0A.1
0133:  BCF    0A.2
0134:  ADDWF  02,F
0135:  RETLW  0C
0136:  RETLW  20
0137:  RETLW  4C
0138:  RETLW  61
0139:  RETLW  73
013A:  RETLW  20
013B:  RETLW  63
013C:  RETLW  6C
013D:  RETLW  61
013E:  RETLW  76
013F:  RETLW  65
0140:  RETLW  73
0141:  RETLW  20
0142:  RETLW  6E
0143:  RETLW  6F
0144:  RETLW  0A
0145:  RETLW  20
0146:  RETLW  20
0147:  RETLW  63
0148:  RETLW  6F
0149:  RETLW  69
014A:  RETLW  6E
014B:  RETLW  63
014C:  RETLW  69
014D:  RETLW  64
014E:  RETLW  65
014F:  RETLW  6E
0150:  RETLW  21
0151:  RETLW  21
0152:  RETLW  21
0153:  RETLW  00
0154:  BSF    0A.0
0155:  BCF    0A.1
0156:  BCF    0A.2
0157:  ADDWF  02,F
0158:  RETLW  0C
0159:  RETLW  20
015A:  RETLW  20
015B:  RETLW  43
015C:  RETLW  6C
015D:  RETLW  61
015E:  RETLW  76
015F:  RETLW  65
0160:  RETLW  3A
0161:  RETLW  0A
0162:  RETLW  20
0163:  RETLW  20
0164:  RETLW  5B
0165:  RETLW  20
0166:  RETLW  20
0167:  RETLW  20
0168:  RETLW  20
0169:  RETLW  20
016A:  RETLW  20
016B:  RETLW  20
016C:  RETLW  20
016D:  RETLW  20
016E:  RETLW  20
016F:  RETLW  5D
0170:  RETLW  00
*
025F:  BCF    0A.0
0260:  BSF    0A.1
0261:  BCF    0A.2
0262:  ADDWF  02,F
0263:  GOTO   24C
0264:  GOTO   24F
0265:  GOTO   252
0266:  GOTO   255
*
02C7:  CLRF   21
02C8:  CLRF   22
02C9:  CLRF   20
02CA:  CLRF   23
02CB:  MOVF   62,W
02CC:  BTFSS  03.2
02CD:  GOTO   2D1
02CE:  MOVF   61,W
02CF:  BTFSC  03.2
02D0:  GOTO   2EB
02D1:  MOVLW  10
02D2:  MOVWF  63
02D3:  BCF    03.0
02D4:  RLF    5F,F
02D5:  RLF    60,F
02D6:  RLF    20,F
02D7:  RLF    23,F
02D8:  MOVF   62,W
02D9:  SUBWF  23,W
02DA:  BTFSS  03.2
02DB:  GOTO   2DE
02DC:  MOVF   61,W
02DD:  SUBWF  20,W
02DE:  BTFSS  03.0
02DF:  GOTO   2E7
02E0:  MOVF   61,W
02E1:  SUBWF  20,F
02E2:  BTFSS  03.0
02E3:  DECF   23,F
02E4:  MOVF   62,W
02E5:  SUBWF  23,F
02E6:  BSF    03.0
02E7:  RLF    21,F
02E8:  RLF    22,F
02E9:  DECFSZ 63,F
02EA:  GOTO   2D3
*
03CF:  CLRF   20
03D0:  CLRF   21
03D1:  MOVF   56,W
03D2:  BCF    03.0
03D3:  BTFSC  57.0
03D4:  ADDWF  20,F
03D5:  RRF    20,F
03D6:  RRF    21,F
03D7:  BTFSC  57.1
03D8:  ADDWF  20,F
03D9:  RRF    20,F
03DA:  RRF    21,F
03DB:  BTFSC  57.2
03DC:  ADDWF  20,F
03DD:  RRF    20,F
03DE:  RRF    21,F
03DF:  BTFSC  57.3
03E0:  ADDWF  20,F
03E1:  RRF    20,F
03E2:  RRF    21,F
03E3:  BTFSC  57.4
03E4:  ADDWF  20,F
03E5:  RRF    20,F
03E6:  RRF    21,F
03E7:  BTFSC  57.5
03E8:  ADDWF  20,F
03E9:  RRF    20,F
03EA:  RRF    21,F
03EB:  BTFSC  57.6
03EC:  ADDWF  20,F
03ED:  RRF    20,F
03EE:  RRF    21,F
03EF:  BTFSC  57.7
03F0:  ADDWF  20,F
03F1:  RRF    20,F
03F2:  RRF    21,F
03F3:  GOTO   578 (RETURN)
03F4:  MOVF   04,W
03F5:  MOVWF  5D
03F6:  SWAPF  57,W
03F7:  IORLW  F0
03F8:  MOVWF  59
03F9:  ADDWF  59,F
03FA:  ADDLW  E2
03FB:  MOVWF  5A
03FC:  ADDLW  32
03FD:  MOVWF  5C
03FE:  MOVF   57,W
03FF:  ANDLW  0F
0400:  ADDWF  5A,F
0401:  ADDWF  5A,F
0402:  ADDWF  5C,F
0403:  ADDLW  E9
0404:  MOVWF  5B
0405:  ADDWF  5B,F
0406:  ADDWF  5B,F
0407:  SWAPF  56,W
0408:  ANDLW  0F
0409:  ADDWF  5B,F
040A:  ADDWF  5C,F
040B:  RLF    5B,F
040C:  RLF    5C,F
040D:  COMF   5C,F
040E:  RLF    5C,F
040F:  MOVF   56,W
0410:  ANDLW  0F
0411:  ADDWF  5C,F
0412:  RLF    59,F
0413:  MOVLW  07
0414:  MOVWF  58
0415:  MOVLW  0A
0416:  ADDWF  5C,F
0417:  DECF   5B,F
0418:  BTFSS  03.0
0419:  GOTO   416
041A:  ADDWF  5B,F
041B:  DECF   5A,F
041C:  BTFSS  03.0
041D:  GOTO   41A
041E:  ADDWF  5A,F
041F:  DECF   59,F
0420:  BTFSS  03.0
0421:  GOTO   41E
0422:  ADDWF  59,F
0423:  DECF   58,F
0424:  BTFSS  03.0
0425:  GOTO   422
0426:  MOVLW  58
0427:  MOVWF  04
0428:  MOVLW  07
0429:  ANDWF  5D,W
042A:  BCF    5D.6
042B:  ADDWF  04,F
042C:  MOVLW  5C
042D:  SUBWF  04,W
042E:  BTFSC  03.2
042F:  BSF    5D.6
0430:  MOVF   00,W
0431:  MOVWF  20
0432:  BTFSS  03.2
0433:  GOTO   43C
0434:  BTFSC  5D.6
0435:  GOTO   43C
0436:  BTFSC  5D.4
0437:  GOTO   448
0438:  BTFSC  5D.3
0439:  GOTO   43C
043A:  MOVLW  20
043B:  GOTO   43F
043C:  BSF    5D.3
043D:  BCF    5D.4
043E:  MOVLW  30
043F:  ADDWF  20,F
0440:  CLRF   57
0441:  MOVF   04,W
0442:  MOVWF  56
0443:  MOVF   20,W
0444:  MOVWF  5E
0445:  CALL   267
0446:  MOVF   56,W
0447:  MOVWF  04
0448:  INCF   04,F
0449:  BTFSS  5D.6
044A:  GOTO   42C
044B:  GOTO   593 (RETURN)
....................  
.................... #list 
....................  
.................... #device adc=16 
....................  
.................... #fuses NOWDT,INTRC_IO,MCLR,NOBROWNOUT,NOPUT,PROTECT,CPD,IESO,FCMEN 
.................... #use delay(clock=4M) 
*
0171:  MOVLW  69
0172:  MOVWF  04
0173:  MOVF   00,W
0174:  BTFSC  03.2
0175:  GOTO   184
0176:  MOVLW  01
0177:  MOVWF  21
0178:  CLRF   20
0179:  DECFSZ 20,F
017A:  GOTO   179
017B:  DECFSZ 21,F
017C:  GOTO   178
017D:  MOVLW  4A
017E:  MOVWF  20
017F:  DECFSZ 20,F
0180:  GOTO   17F
0181:  GOTO   182
0182:  DECFSZ 00,F
0183:  GOTO   176
0184:  RETURN
....................  
.................... #byte TRISA = 0x85 
.................... #byte TRISB = 0x86 
.................... #byte TRISC = 0x87 
.................... #byte PORTA = 0x05 
.................... #byte PORTB = 0x06 
.................... #byte PORTC = 0x07 
.................... //Puerto A 
.................... #bit sensor     = 0x05.0 
.................... #bit pin_intext = 0x05.1 
.................... #bit pin_abrir  = 0x05.4 
.................... #bit pin_cerrar = 0x05.5 
.................... //Puerto B 
.................... #bit trisadcb4  = 0x86.4 
.................... #bit trisadcb5  = 0x86.5 
.................... #bit adcB5      = 0x06.5 
.................... #bit ilumin     = 0x06.6 
....................  
.................... #define tam_psw      10 
.................... #define sensibilidad 18000 
....................  
.................... #include <lcd_pc_a_677.c> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... #bit tris_enable=0x86.7 
.................... #bit enable=0x06.7 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN sin_usar;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................        
....................          
....................          
....................  
.................... //#define use_portd_lcd TRUE 
....................  
.................... #locate lcd = getenv("SFR:PORTC")                  // This puts the entire structure 
....................                                      // on to port B  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       tris_enable=0; 
*
01D3:  BSF    03.5
01D4:  BCF    06.7
....................       set_tris_c(LCD_READ); 
01D5:  MOVLW  F0
01D6:  MOVWF  07
....................       lcd.rw = 1; 
01D7:  BCF    03.5
01D8:  BSF    07.2
....................       delay_cycles(1); 
01D9:  NOP
....................       enable = 1; 
01DA:  BSF    06.7
....................       delay_cycles(1); 
01DB:  NOP
....................       high = lcd.data; 
01DC:  MOVF   07,W
01DD:  SWAPF  07,W
01DE:  ANDLW  0F
01DF:  MOVWF  65
....................       enable = 0; 
01E0:  BCF    06.7
....................       delay_cycles(1); 
01E1:  NOP
....................       enable = 1; 
01E2:  BSF    06.7
....................       delay_us(1); 
01E3:  NOP
....................       low = lcd.data; 
01E4:  MOVF   07,W
01E5:  SWAPF  07,W
01E6:  ANDLW  0F
01E7:  MOVWF  64
....................       enable = 0; 
01E8:  BCF    06.7
....................       tris_enable=0; 
01E9:  BSF    03.5
01EA:  BCF    06.7
....................       set_tris_c(LCD_WRITE); 
01EB:  MOVLW  00
01EC:  MOVWF  07
....................       return( (high<<4) | low); 
01ED:  BCF    03.5
01EE:  SWAPF  65,W
01EF:  MOVWF  20
01F0:  MOVLW  F0
01F1:  ANDWF  20,F
01F2:  MOVF   20,W
01F3:  IORWF  64,W
01F4:  MOVWF  21
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
01C6:  SWAPF  65,W
01C7:  ANDLW  F0
01C8:  MOVWF  20
01C9:  MOVLW  0F
01CA:  ANDWF  07,W
01CB:  IORWF  20,W
01CC:  MOVWF  07
....................       delay_cycles(1); 
01CD:  NOP
....................       enable = 1; 
01CE:  BSF    06.7
....................       delay_us(2); 
01CF:  GOTO   1D0
....................       enable = 0; 
01D0:  BCF    06.7
01D1:  RETURN
.................... } 
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
01D2:  BCF    07.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
01F5:  MOVF   21,W
01F6:  MOVWF  64
01F7:  BTFSC  64.7
01F8:  GOTO   1D3
....................       lcd.rs = address; 
01F9:  BTFSS  62.0
01FA:  BCF    07.1
01FB:  BTFSC  62.0
01FC:  BSF    07.1
....................       delay_cycles(1); 
01FD:  NOP
....................       lcd.rw = 0; 
01FE:  BCF    07.2
....................       delay_cycles(1); 
01FF:  NOP
....................       enable = 0; 
0200:  BCF    06.7
....................       lcd_send_nibble(n >> 4); 
0201:  SWAPF  63,W
0202:  MOVWF  64
0203:  MOVLW  0F
0204:  ANDWF  64,F
0205:  MOVF   64,W
0206:  MOVWF  65
0207:  CALL   1C6
....................       lcd_send_nibble(n & 0xf); 
0208:  MOVF   63,W
0209:  ANDLW  0F
020A:  MOVWF  64
020B:  MOVWF  65
020C:  CALL   1C6
020D:  RETURN
.................... } 
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     tris_enable=0; 
020E:  BSF    03.5
020F:  BCF    06.7
....................     set_tris_c(LCD_WRITE); 
0210:  MOVLW  00
0211:  MOVWF  07
....................     lcd.rs = 0; 
0212:  BCF    03.5
0213:  BCF    07.1
....................     lcd.rw = 0; 
0214:  BCF    07.2
....................     enable = 0; 
0215:  BCF    06.7
0216:  CLRF   2C
0217:  BTFSC  0B.7
0218:  BSF    2C.7
0219:  BCF    0B.7
....................     delay_ms(15); 
021A:  MOVLW  0F
021B:  MOVWF  69
021C:  CALL   171
021D:  BTFSC  2C.7
021E:  BSF    0B.7
....................     for(i=1;i<=3;++i) { 
021F:  MOVLW  01
0220:  MOVWF  58
0221:  MOVF   58,W
0222:  SUBLW  03
0223:  BTFSS  03.0
0224:  GOTO   233
....................        lcd_send_nibble(3); 
0225:  MOVLW  03
0226:  MOVWF  65
0227:  CALL   1C6
0228:  CLRF   2C
0229:  BTFSC  0B.7
022A:  BSF    2C.7
022B:  BCF    0B.7
....................        delay_ms(5); 
022C:  MOVLW  05
022D:  MOVWF  69
022E:  CALL   171
022F:  BTFSC  2C.7
0230:  BSF    0B.7
0231:  INCF   58,F
0232:  GOTO   221
....................     } 
....................     lcd_send_nibble(2); 
0233:  MOVLW  02
0234:  MOVWF  65
0235:  CALL   1C6
....................     for(i=0;i<=3;++i) 
0236:  CLRF   58
0237:  MOVF   58,W
0238:  SUBLW  03
0239:  BTFSS  03.0
023A:  GOTO   244
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
023B:  MOVF   58,W
023C:  CALL   033
023D:  MOVWF  59
023E:  CLRF   62
023F:  MOVF   59,W
0240:  MOVWF  63
0241:  CALL   1D2
0242:  INCF   58,F
0243:  GOTO   237
0244:  RETURN
.................... } 
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
0245:  MOVLW  01
0246:  SUBWF  60,W
0247:  ADDLW  FC
0248:  BTFSC  03.0
0249:  GOTO   257
024A:  ADDLW  04
024B:  GOTO   25F
....................      case 1 : address=0x80;break; 
024C:  MOVLW  80
024D:  MOVWF  61
024E:  GOTO   257
....................      case 2 : address=0xc0;break; 
024F:  MOVLW  C0
0250:  MOVWF  61
0251:  GOTO   257
....................      case 3 : address=0x94;break; 
0252:  MOVLW  94
0253:  MOVWF  61
0254:  GOTO   257
....................      case 4 : address=0xd4;break; 
0255:  MOVLW  D4
0256:  MOVWF  61
....................    } 
....................    address+=x-1; 
0257:  MOVLW  01
0258:  SUBWF  5F,W
0259:  ADDWF  61,F
....................    lcd_send_byte(0,address); 
025A:  CLRF   62
025B:  MOVF   61,W
025C:  MOVWF  63
025D:  CALL   1D2
025E:  RETURN
.................... } 
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
0267:  MOVF   5E,W
0268:  XORLW  0C
0269:  BTFSC  03.2
026A:  GOTO   272
026B:  XORLW  06
026C:  BTFSC  03.2
026D:  GOTO   282
026E:  XORLW  02
026F:  BTFSC  03.2
0270:  GOTO   289
0271:  GOTO   28E
....................      case '\f'   : lcd_send_byte(0,1); 
0272:  CLRF   62
0273:  MOVLW  01
0274:  MOVWF  63
0275:  CALL   1D2
....................                    lcdline=1; 
0276:  MOVLW  01
0277:  MOVWF  2D
0278:  CLRF   2C
0279:  BTFSC  0B.7
027A:  BSF    2C.7
027B:  BCF    0B.7
....................                    delay_ms(2); 
027C:  MOVLW  02
027D:  MOVWF  69
027E:  CALL   171
027F:  BTFSC  2C.7
0280:  BSF    0B.7
....................                                            break; 
0281:  GOTO   293
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
0282:  INCF   2D,F
0283:  MOVLW  01
0284:  MOVWF  5F
0285:  MOVF   2D,W
0286:  MOVWF  60
0287:  CALL   245
0288:  GOTO   293
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0289:  CLRF   62
028A:  MOVLW  10
028B:  MOVWF  63
028C:  CALL   1D2
028D:  GOTO   293
....................      default     : lcd_send_byte(1,c);     break; 
028E:  MOVLW  01
028F:  MOVWF  62
0290:  MOVF   5E,W
0291:  MOVWF  63
0292:  CALL   1D2
....................    } 
0293:  RETURN
.................... } 
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <keypad_4x4.c> 
.................... /////////////////////////////////////////////////////////////////////// 
.................... // Libreria: KBD4x4.C 
.................... // 
.................... // char kbd_getc()   Devuelve el código ASCII de la tecla pulsada. 
.................... //         Si no se pulsó ninguna, devuelve 0. 
.................... // 
.................... // Conexiones del teclado. 
.................... //            RB0 RB1 RB2 RB3 
.................... //             ^   ^   ^   ^ 
.................... //             |   |   |   | 
.................... //           |---|---|---|---| 
.................... //  RB4 ---> | 1 | 2 | 3 | A | 
.................... //           |---|---|---|---| 
.................... //  RB5 ---> | 6 | 5 | 4 | B | 
.................... //           |---|---|---|---| 
.................... //  RB6 ---> | 7 | 8 | 9 | C | 
.................... //           |---|---|---|---| 
.................... //  RB7 ---> | * | 0 | # | D | 
.................... //           |---|---|---|---| 
.................... /////////////////////////////////////////////////////////////////////// 
....................  
.................... // Caracteres ASCII asociados a cada tecla: 
.................... char const KEYS[4][4] = {{'1','4','7','*'}, 
....................                          {'2','5','8','0'}, 
....................                          {'3','6','9','#'}, 
....................                          {'A','B','C','D'}}; 
....................  
.................... #byte kbd_port_c = 0x07 
....................  
....................  
.................... char kbd_getc() 
*
030C:  CLRF   59
.................... { 
....................   char tecla=0; 
....................   int f,c,t,i,j; 
....................  
....................   set_tris_c(0b00001111); // RB7-RB4 salidas, RB3-RB0 entradas 
030D:  MOVLW  0F
030E:  BSF    03.5
030F:  MOVWF  07
....................  
....................   for(f=0x10, i=0; i<4; f<<=1, i++) 
0310:  MOVLW  10
0311:  BCF    03.5
0312:  MOVWF  5A
0313:  CLRF   5D
0314:  MOVF   5D,W
0315:  SUBLW  03
0316:  BTFSS  03.0
0317:  GOTO   35A
....................   { 
....................     for(c=0x01, j=0; j<4; c<<=1, j++) 
0318:  MOVLW  01
0319:  MOVWF  5B
031A:  CLRF   5E
031B:  MOVF   5E,W
031C:  SUBLW  03
031D:  BTFSS  03.0
031E:  GOTO   353
....................     { 
....................       kbd_port_c = ~f; 
031F:  MOVF   5A,W
0320:  MOVWF  07
0321:  COMF   07,F
....................       delay_cycles(1); 
0322:  NOP
....................       t = kbd_port_c & 0x0F; 
0323:  MOVF   07,W
0324:  ANDLW  0F
0325:  MOVWF  5C
....................       t = ~(t | 0xF0); 
0326:  MOVF   5C,W
0327:  IORLW  F0
0328:  XORLW  FF
0329:  MOVWF  5C
....................       if(t == c) 
032A:  MOVF   5B,W
032B:  SUBWF  5C,W
032C:  BTFSS  03.2
032D:  GOTO   34F
032E:  CLRF   2C
032F:  BTFSC  0B.7
0330:  BSF    2C.7
0331:  BCF    0B.7
....................       { 
....................         delay_ms(20); 
0332:  MOVLW  14
0333:  MOVWF  69
0334:  CALL   171
0335:  BTFSC  2C.7
0336:  BSF    0B.7
....................         tecla=KEYS[i][j]; 
0337:  RLF    5D,W
0338:  MOVWF  20
0339:  RLF    20,F
033A:  MOVLW  FC
033B:  ANDWF  20,F
033C:  MOVF   20,W
033D:  ADDWF  5E,W
033E:  CALL   03B
033F:  MOVWF  21
0340:  MOVWF  59
....................         while(t==c) 
0341:  MOVF   5B,W
0342:  SUBWF  5C,W
0343:  BTFSS  03.2
0344:  GOTO   34E
....................         { 
....................           restart_wdt(); 
0345:  CLRWDT
....................           t = kbd_port_c & 0x0F; 
0346:  MOVF   07,W
0347:  ANDLW  0F
0348:  MOVWF  5C
....................           t = ~(t | 0xF0); 
0349:  MOVF   5C,W
034A:  IORLW  F0
034B:  XORLW  FF
034C:  MOVWF  5C
034D:  GOTO   341
....................         } 
....................         break; 
034E:  GOTO   353
....................       } 
034F:  BCF    03.0
0350:  RLF    5B,F
0351:  INCF   5E,F
0352:  GOTO   31B
....................     } 
....................     if(tecla) 
0353:  MOVF   59,F
0354:  BTFSS  03.2
....................       break; 
0355:  GOTO   35A
0356:  BCF    03.0
0357:  RLF    5A,F
0358:  INCF   5D,F
0359:  GOTO   314
....................   } 
....................   return tecla; 
035A:  MOVF   59,W
035B:  MOVWF  21
.................... } 
....................  
.................... //Uso de variables generales 
....................    short flag,flag_touch=false; 
....................    const char master_key[tam_psw+1]={"0ABCD28823"}; 
....................    int inten=0,t0=0; 
....................    char key,psw[tam_psw],psw1[tam_psw],psw_intr[tam_psw]; 
....................    //long ; 
.................... //Prototipos de funciones 
....................    void AbrirIntExt(); 
....................    void LucesLcd(); 
....................    void IntrClave(char *clave); 
....................    short CompararClave(char *s1,char *s2); 
....................    short IsMaster(char *sm); 
....................    char ReciveTecla(); 
....................    short IsTouched(); 
....................    void Abrir(); 
.................... //Interrupción Externa 
.................... #int_ext 
.................... void AbrirIntExt() 
.................... { 
....................    if(flag_touch) 
*
01AC:  BTFSS  2E.1
01AD:  GOTO   1B6
....................    { 
....................       if(!ilumin) 
01AE:  BTFSC  06.6
01AF:  GOTO   1B2
....................       { 
....................          enable_interrupts(int_timer0); 
01B0:  BSF    0B.5
....................          ilumin=true; 
01B1:  BSF    06.6
....................       } 
....................       t0=0; 
01B2:  CLRF   30
....................       pin_intext=false; 
01B3:  BCF    05.1
....................       Abrir();       
01B4:  CALL   185
....................    } 
01B5:  GOTO   1B7
....................    else 
....................       flag_touch=true; 
01B6:  BSF    2E.1
.................... } 
.................... //Interrupcion Timer0 
01B7:  BCF    0B.1
01B8:  BCF    0A.3
01B9:  GOTO   022
.................... #int_timer0 
.................... void LucesLcd() 
.................... { 
....................    if (t0>120) 
01BA:  MOVF   30,W
01BB:  SUBLW  78
01BC:  BTFSC  03.0
01BD:  GOTO   1C2
....................    { 
....................       t0=0; 
01BE:  CLRF   30
....................       disable_interrupts(int_timer0); 
01BF:  BCF    0B.5
....................       ilumin=false; 
01C0:  BCF    06.6
....................    } 
01C1:  GOTO   1C3
....................    else  
....................       t0++; 
01C2:  INCF   30,F
01C3:  BCF    0B.2
01C4:  BCF    0A.3
01C5:  GOTO   022
.................... } 
.................... //Programa principal 
.................... void main() 
*
0463:  MOVLW  61
0464:  BSF    03.5
0465:  MOVWF  0F
0466:  MOVF   0F,W
0467:  BCF    03.5
0468:  BCF    2E.1
0469:  CLRF   2F
046A:  CLRF   30
046B:  BSF    03.6
046C:  BCF    1F.0
046D:  BCF    1F.1
046E:  BCF    1F.2
046F:  BCF    1F.3
0470:  BCF    03.6
0471:  BCF    1F.6
0472:  MOVLW  00
0473:  BSF    03.6
0474:  MOVWF  1E
0475:  CLRF   19
0476:  CLRF   1A
0477:  BSF    03.5
0478:  CLRF   1E
0479:  BCF    03.5
047A:  CLRF   1B
047B:  BCF    03.6
047C:  BCF    0D.5
047D:  MOVLW  1F
047E:  ANDWF  03,F
.................... { 
....................    setup_oscillator(OSC_4MHZ); 
047F:  MOVLW  61
0480:  BSF    03.5
0481:  MOVWF  0F
0482:  MOVF   0F,W
....................    lcd_init(); 
0483:  BCF    03.5
0484:  CALL   20E
....................    TRISC=0x00; TRISA=0x0D; TRISB=0x00;  
0485:  BSF    03.5
0486:  CLRF   07
0487:  MOVLW  0D
0488:  MOVWF  05
0489:  CLRF   06
....................    PORTC=0x00; PORTA=0x00; PORTB=0x00;  
048A:  BCF    03.5
048B:  CLRF   07
048C:  CLRF   05
048D:  CLRF   06
....................    setup_adc_ports(sAN10 | sAN11); 
048E:  BSF    03.6
048F:  BCF    1F.0
0490:  BCF    1F.1
0491:  BSF    1F.2
0492:  BSF    1F.3
0493:  BCF    03.6
0494:  BCF    1F.6
0495:  MOVLW  00
0496:  BSF    03.6
0497:  MOVWF  1E
....................    setup_adc(ADC_CLOCK_INTERNAL); 
0498:  BSF    03.5
0499:  BCF    03.6
049A:  BSF    1F.4
049B:  BSF    1F.5
049C:  BCF    1F.6
049D:  BCF    03.5
049E:  BCF    1F.7
049F:  BSF    1F.0
....................    setup_timer_0(T0_INTERNAL|T0_DIV_256); 
04A0:  BSF    03.5
04A1:  MOVF   01,W
04A2:  ANDLW  C0
04A3:  IORLW  07
04A4:  MOVWF  01
....................    set_adc_channel(11); 
04A5:  MOVLW  2C
04A6:  BCF    03.5
04A7:  MOVWF  21
04A8:  MOVF   1F,W
04A9:  ANDLW  C3
04AA:  IORWF  21,W
04AB:  MOVWF  1F
04AC:  CLRF   2C
04AD:  BTFSC  0B.7
04AE:  BSF    2C.7
04AF:  BCF    0B.7
....................    delay_ms(250); 
04B0:  MOVLW  FA
04B1:  MOVWF  69
04B2:  CALL   171
04B3:  BTFSC  2C.7
04B4:  BSF    0B.7
....................    enable_interrupts(int_ext); 
04B5:  BSF    0B.4
....................    ext_int_edge(l_to_h); 
04B6:  BSF    03.5
04B7:  BSF    01.6
....................    enable_interrupts(GLOBAL); 
04B8:  MOVLW  C0
04B9:  BCF    03.5
04BA:  IORWF  0B,F
....................    if(read_eeprom(255)!=1) 
04BB:  MOVLW  FF
04BC:  BSF    03.6
04BD:  MOVWF  0D
04BE:  BSF    03.5
04BF:  BCF    0C.7
04C0:  BSF    0C.0
04C1:  BCF    03.5
04C2:  MOVF   0C,W
04C3:  SUBLW  01
04C4:  BTFSC  03.2
04C5:  GOTO   502
....................    { 
....................       for (int i = 0; i < tam_psw; ++i) 
04C6:  BCF    03.6
04C7:  CLRF   50
04C8:  MOVF   50,W
04C9:  SUBLW  09
04CA:  BTFSS  03.0
04CB:  GOTO   4EA
....................          write_eeprom(i,master_key[i]); 
04CC:  MOVF   50,W
04CD:  CALL   04F
04CE:  MOVWF  56
04CF:  MOVF   0B,W
04D0:  MOVWF  20
04D1:  BCF    0B.7
04D2:  MOVF   50,W
04D3:  BSF    03.6
04D4:  MOVWF  0D
04D5:  BCF    03.6
04D6:  MOVF   56,W
04D7:  BSF    03.6
04D8:  MOVWF  0C
04D9:  BSF    03.5
04DA:  BCF    0C.7
04DB:  BSF    0C.2
04DC:  MOVLW  55
04DD:  MOVWF  0D
04DE:  MOVLW  AA
04DF:  MOVWF  0D
04E0:  BSF    0C.1
04E1:  BTFSC  0C.1
04E2:  GOTO   4E1
04E3:  BCF    0C.2
04E4:  BCF    03.5
04E5:  BCF    03.6
04E6:  MOVF   20,W
04E7:  IORWF  0B,F
04E8:  INCF   50,F
04E9:  GOTO   4C8
....................       write_eeprom(255,1); 
04EA:  MOVF   0B,W
04EB:  MOVWF  20
04EC:  BCF    0B.7
04ED:  MOVLW  FF
04EE:  BSF    03.6
04EF:  MOVWF  0D
04F0:  MOVLW  01
04F1:  MOVWF  0C
04F2:  BSF    03.5
04F3:  BCF    0C.7
04F4:  BSF    0C.2
04F5:  MOVLW  55
04F6:  MOVWF  0D
04F7:  MOVLW  AA
04F8:  MOVWF  0D
04F9:  BSF    0C.1
04FA:  BTFSC  0C.1
04FB:  GOTO   4FA
04FC:  BCF    0C.2
04FD:  BCF    03.5
04FE:  BCF    03.6
04FF:  MOVF   20,W
0500:  IORWF  0B,F
0501:  BSF    03.6
....................    } 
....................    for (int i = 0; i < tam_psw; ++i) 
0502:  BCF    03.6
0503:  CLRF   51
0504:  MOVF   51,W
0505:  SUBLW  09
0506:  BTFSS  03.0
0507:  GOTO   517
....................       psw[i]=read_eeprom(i); 
0508:  MOVLW  32
0509:  ADDWF  51,W
050A:  MOVWF  04
050B:  MOVF   51,W
050C:  BSF    03.6
050D:  MOVWF  0D
050E:  BSF    03.5
050F:  BCF    0C.7
0510:  BSF    0C.0
0511:  BCF    03.5
0512:  MOVF   0C,W
0513:  MOVWF  00
0514:  BCF    03.6
0515:  INCF   51,F
0516:  GOTO   504
....................    while(true) 
....................    { 
....................       lcd_putc("\f   Introduce\n   la Clave"); 
0517:  CLRF   56
0518:  MOVF   56,W
0519:  CALL   05E
051A:  IORLW  00
051B:  BTFSC  03.2
051C:  GOTO   521
051D:  INCF   56,F
051E:  MOVWF  5E
051F:  CALL   267
0520:  GOTO   518
....................       do 
....................       { 
....................          key=ReciveTecla(); 
0521:  CALL   294
0522:  MOVF   21,W
0523:  MOVWF  31
0524:  CLRF   2C
0525:  BTFSC  0B.7
0526:  BSF    2C.7
0527:  BCF    0B.7
....................          delay_ms(15); 
0528:  MOVLW  0F
0529:  MOVWF  69
052A:  CALL   171
052B:  BTFSC  2C.7
052C:  BSF    0B.7
....................       }while(!key); 
052D:  MOVF   31,F
052E:  BTFSC  03.2
052F:  GOTO   521
0530:  CLRF   2C
0531:  BTFSC  0B.7
0532:  BSF    2C.7
0533:  BCF    0B.7
....................       delay_ms(250); 
0534:  MOVLW  FA
0535:  MOVWF  69
0536:  CALL   171
0537:  BTFSC  2C.7
0538:  BSF    0B.7
....................       flag = (key=='*')? false : true; 
0539:  MOVF   31,W
053A:  SUBLW  2A
053B:  BTFSS  03.2
053C:  GOTO   53F
053D:  MOVLW  00
053E:  GOTO   540
053F:  MOVLW  01
0540:  MOVWF  21
0541:  BCF    2E.0
0542:  BTFSC  21.0
0543:  BSF    2E.0
....................       if (flag) 
0544:  BTFSS  2E.0
0545:  GOTO   5B8
....................       { 
....................          IntrClave(psw_intr); 
0546:  MOVLW  46
0547:  MOVWF  56
0548:  CALL   369
....................          if (CompararClave(psw,psw_intr)) 
0549:  MOVLW  32
054A:  MOVWF  56
054B:  MOVLW  46
054C:  MOVWF  57
054D:  CALL   3B6
054E:  MOVF   21,F
054F:  BTFSC  03.2
0550:  GOTO   564
....................          { 
....................             inten=0; 
0551:  CLRF   2F
....................             lcd_putc("\f   Abierto"); 
0552:  CLRF   56
0553:  MOVF   56,W
0554:  CALL   07C
0555:  IORLW  00
0556:  BTFSC  03.2
0557:  GOTO   55C
0558:  INCF   56,F
0559:  MOVWF  5E
055A:  CALL   267
055B:  GOTO   553
055C:  CLRF   2C
055D:  BTFSC  0B.7
055E:  BSF    2C.7
055F:  BCF    0B.7
....................             Abrir(); 
0560:  CALL   185
0561:  BTFSC  2C.7
0562:  BSF    0B.7
....................          } 
0563:  GOTO   56F
....................          else 
....................          { 
....................             lcd_putc("\f   Clave\n  Incorrecta"); 
0564:  CLRF   56
0565:  MOVF   56,W
0566:  CALL   08C
0567:  IORLW  00
0568:  BTFSC  03.2
0569:  GOTO   56E
056A:  INCF   56,F
056B:  MOVWF  5E
056C:  CALL   267
056D:  GOTO   565
....................             inten++; 
056E:  INCF   2F,F
....................          }             
....................          if(inten>5) 
056F:  MOVF   2F,W
0570:  SUBLW  05
0571:  BTFSC  03.0
0572:  GOTO   5B7
....................             for (long j = 5*inten; j>0 ; --j) 
0573:  MOVLW  05
0574:  MOVWF  56
0575:  MOVF   2F,W
0576:  MOVWF  57
0577:  GOTO   3CF
0578:  CLRF   53
0579:  MOVF   21,W
057A:  MOVWF  52
057B:  MOVF   52,F
057C:  BTFSS  03.2
057D:  GOTO   581
057E:  MOVF   53,F
057F:  BTFSC  03.2
0580:  GOTO   5B7
....................             { 
....................                printf(lcd_putc,"\f   Bloqueado\n espera %Lu seg", j); 
0581:  CLRF   56
0582:  MOVF   56,W
0583:  CALL   0A7
0584:  INCF   56,F
0585:  MOVWF  20
0586:  MOVWF  5E
0587:  CALL   267
0588:  MOVLW  16
0589:  SUBWF  56,W
058A:  BTFSS  03.2
058B:  GOTO   582
058C:  MOVLW  10
058D:  MOVWF  04
058E:  MOVF   53,W
058F:  MOVWF  57
0590:  MOVF   52,W
0591:  MOVWF  56
0592:  GOTO   3F4
0593:  MOVLW  19
0594:  MOVWF  56
0595:  MOVF   56,W
0596:  CALL   0A7
0597:  INCF   56,F
0598:  MOVWF  20
0599:  MOVWF  5E
059A:  CALL   267
059B:  MOVLW  1D
059C:  SUBWF  56,W
059D:  BTFSS  03.2
059E:  GOTO   595
....................                for (int i = 0; i < 10; ++i) 
059F:  CLRF   54
05A0:  MOVF   54,W
05A1:  SUBLW  09
05A2:  BTFSS  03.0
05A3:  GOTO   5B2
....................                { 
....................                   key=ReciveTecla(); 
05A4:  CALL   294
05A5:  MOVF   21,W
05A6:  MOVWF  31
05A7:  CLRF   2C
05A8:  BTFSC  0B.7
05A9:  BSF    2C.7
05AA:  BCF    0B.7
....................                   delay_ms(80); 
05AB:  MOVLW  50
05AC:  MOVWF  69
05AD:  CALL   171
05AE:  BTFSC  2C.7
05AF:  BSF    0B.7
05B0:  INCF   54,F
05B1:  GOTO   5A0
....................                } 
05B2:  MOVF   52,W
05B3:  BTFSC  03.2
05B4:  DECF   53,F
05B5:  DECF   52,F
05B6:  GOTO   57B
....................             } 
....................       } 
05B7:  GOTO   663
....................       else 
....................       { 
....................          IntrClave(psw_intr); 
05B8:  MOVLW  46
05B9:  MOVWF  56
05BA:  CALL   369
....................          if (CompararClave(psw,psw_intr) || IsMaster(psw_intr)) 
05BB:  MOVLW  32
05BC:  MOVWF  56
05BD:  MOVLW  46
05BE:  MOVWF  57
05BF:  CALL   3B6
05C0:  MOVF   21,F
05C1:  BTFSS  03.2
05C2:  GOTO   5C9
05C3:  MOVLW  46
05C4:  MOVWF  56
05C5:  GOTO   44C
05C6:  MOVF   21,F
05C7:  BTFSC  03.2
05C8:  GOTO   659
....................          { 
....................             lcd_putc("\f Introduce una\n  nueva clave"); 
05C9:  CLRF   56
05CA:  MOVF   56,W
05CB:  CALL   0C9
05CC:  IORLW  00
05CD:  BTFSC  03.2
05CE:  GOTO   5D3
05CF:  INCF   56,F
05D0:  MOVWF  5E
05D1:  CALL   267
05D2:  GOTO   5CA
....................             delay_ms(1200); 
05D3:  MOVLW  05
05D4:  MOVWF  56
05D5:  CLRF   2C
05D6:  BTFSC  0B.7
05D7:  BSF    2C.7
05D8:  BCF    0B.7
05D9:  MOVLW  F0
05DA:  MOVWF  69
05DB:  CALL   171
05DC:  BTFSC  2C.7
05DD:  BSF    0B.7
05DE:  DECFSZ 56,F
05DF:  GOTO   5D5
....................             IntrClave(psw_intr); 
05E0:  MOVLW  46
05E1:  MOVWF  56
05E2:  CALL   369
....................             lcd_putc("\f   Vuelvela a\n   introducir"); 
05E3:  CLRF   56
05E4:  MOVF   56,W
05E5:  CALL   0EB
05E6:  IORLW  00
05E7:  BTFSC  03.2
05E8:  GOTO   5ED
05E9:  INCF   56,F
05EA:  MOVWF  5E
05EB:  CALL   267
05EC:  GOTO   5E4
....................             delay_ms(1200); 
05ED:  MOVLW  05
05EE:  MOVWF  56
05EF:  CLRF   2C
05F0:  BTFSC  0B.7
05F1:  BSF    2C.7
05F2:  BCF    0B.7
05F3:  MOVLW  F0
05F4:  MOVWF  69
05F5:  CALL   171
05F6:  BTFSC  2C.7
05F7:  BSF    0B.7
05F8:  DECFSZ 56,F
05F9:  GOTO   5EF
....................             IntrClave(psw1); 
05FA:  MOVLW  3C
05FB:  MOVWF  56
05FC:  CALL   369
....................             if(CompararClave(psw1,psw_intr)) 
05FD:  MOVLW  3C
05FE:  MOVWF  56
05FF:  MOVLW  46
0600:  MOVWF  57
0601:  CALL   3B6
0602:  MOVF   21,F
0603:  BTFSC  03.2
0604:  GOTO   64E
....................             { 
....................                lcd_putc("\f  La clave ha\n sido cambiada"); 
0605:  CLRF   56
0606:  MOVF   56,W
0607:  CALL   10F
0608:  IORLW  00
0609:  BTFSC  03.2
060A:  GOTO   60F
060B:  INCF   56,F
060C:  MOVWF  5E
060D:  CALL   267
060E:  GOTO   606
....................                for (int i = 0; i < tam_psw; ++i) 
060F:  CLRF   55
0610:  MOVF   55,W
0611:  SUBLW  09
0612:  BTFSS  03.0
0613:  GOTO   640
....................                { 
....................                   write_eeprom(i,psw_intr[i]); 
0614:  MOVLW  46
0615:  ADDWF  55,W
0616:  MOVWF  04
0617:  MOVF   00,W
0618:  MOVWF  56
0619:  MOVF   0B,W
061A:  MOVWF  20
061B:  BCF    0B.7
061C:  MOVF   55,W
061D:  BSF    03.6
061E:  MOVWF  0D
061F:  BCF    03.6
0620:  MOVF   56,W
0621:  BSF    03.6
0622:  MOVWF  0C
0623:  BSF    03.5
0624:  BCF    0C.7
0625:  BSF    0C.2
0626:  MOVLW  55
0627:  MOVWF  0D
0628:  MOVLW  AA
0629:  MOVWF  0D
062A:  BSF    0C.1
062B:  BTFSC  0C.1
062C:  GOTO   62B
062D:  BCF    0C.2
062E:  BCF    03.5
062F:  BCF    03.6
0630:  MOVF   20,W
0631:  IORWF  0B,F
....................                   psw[i]=psw_intr[i]; 
0632:  MOVLW  32
0633:  ADDWF  55,W
0634:  MOVWF  56
0635:  MOVLW  46
0636:  ADDWF  55,W
0637:  MOVWF  04
0638:  MOVF   00,W
0639:  MOVWF  57
063A:  MOVF   56,W
063B:  MOVWF  04
063C:  MOVF   57,W
063D:  MOVWF  00
063E:  INCF   55,F
063F:  GOTO   610
....................                } 
....................                delay_ms(500); 
0640:  MOVLW  02
0641:  MOVWF  56
0642:  CLRF   2C
0643:  BTFSC  0B.7
0644:  BSF    2C.7
0645:  BCF    0B.7
0646:  MOVLW  FA
0647:  MOVWF  69
0648:  CALL   171
0649:  BTFSC  2C.7
064A:  BSF    0B.7
064B:  DECFSZ 56,F
064C:  GOTO   642
....................             } 
064D:  GOTO   658
....................             else 
....................                lcd_putc("\f Las claves no\n  coinciden!!!"); 
064E:  CLRF   56
064F:  MOVF   56,W
0650:  CALL   131
0651:  IORLW  00
0652:  BTFSC  03.2
0653:  GOTO   658
0654:  INCF   56,F
0655:  MOVWF  5E
0656:  CALL   267
0657:  GOTO   64F
....................          } 
0658:  GOTO   663
....................          else 
....................             lcd_putc("\f   Clave\n  Incorrecta"); 
0659:  CLRF   56
065A:  MOVF   56,W
065B:  CALL   08C
065C:  IORLW  00
065D:  BTFSC  03.2
065E:  GOTO   663
065F:  INCF   56,F
0660:  MOVWF  5E
0661:  CALL   267
0662:  GOTO   65A
....................       } 
....................       delay_ms(1000); 
0663:  MOVLW  04
0664:  MOVWF  56
0665:  CLRF   2C
0666:  BTFSC  0B.7
0667:  BSF    2C.7
0668:  BCF    0B.7
0669:  MOVLW  FA
066A:  MOVWF  69
066B:  CALL   171
066C:  BTFSC  2C.7
066D:  BSF    0B.7
066E:  DECFSZ 56,F
066F:  GOTO   665
0670:  GOTO   517
....................    } 
.................... } 
.................... void IntrClave(char *clave) 
0671:  SLEEP
.................... { 
....................    lcd_init(); 
*
0369:  CALL   20E
....................    lcd_putc("\f  Clave:\n  [          ]"); 
036A:  CLRF   58
036B:  MOVF   58,W
036C:  CALL   154
036D:  IORLW  00
036E:  BTFSC  03.2
036F:  GOTO   374
0370:  INCF   58,F
0371:  MOVWF  5E
0372:  CALL   267
0373:  GOTO   36B
....................    lcd_gotoxy(4,2); 
0374:  MOVLW  04
0375:  MOVWF  5F
0376:  MOVLW  02
0377:  MOVWF  60
0378:  CALL   245
....................    for (int i = 0; i < tam_psw ; ++i) 
0379:  CLRF   57
037A:  MOVF   57,W
037B:  SUBLW  09
037C:  BTFSS  03.0
037D:  GOTO   3A8
....................    { 
....................       do 
....................       {         
....................          key=ReciveTecla(); 
037E:  CALL   294
037F:  MOVF   21,W
0380:  MOVWF  31
....................          if(key=='*' || key=='#') 
0381:  MOVF   31,W
0382:  SUBLW  2A
0383:  BTFSC  03.2
0384:  GOTO   388
0385:  MOVF   31,W
0386:  SUBLW  23
0387:  BTFSC  03.2
....................             key=0; 
0388:  CLRF   31
0389:  CLRF   2C
038A:  BTFSC  0B.7
038B:  BSF    2C.7
038C:  BCF    0B.7
....................          delay_ms(15); 
038D:  MOVLW  0F
038E:  MOVWF  69
038F:  CALL   171
0390:  BTFSC  2C.7
0391:  BSF    0B.7
....................       }while(!key); 
0392:  MOVF   31,F
0393:  BTFSC  03.2
0394:  GOTO   37E
0395:  CLRF   2C
0396:  BTFSC  0B.7
0397:  BSF    2C.7
0398:  BCF    0B.7
....................       delay_ms(150); 
0399:  MOVLW  96
039A:  MOVWF  69
039B:  CALL   171
039C:  BTFSC  2C.7
039D:  BSF    0B.7
....................       clave[i]=key; 
039E:  MOVF   56,W
039F:  ADDWF  57,W
03A0:  MOVWF  04
03A1:  MOVF   31,W
03A2:  MOVWF  00
....................       lcd_putc('*'); 
03A3:  MOVLW  2A
03A4:  MOVWF  5E
03A5:  CALL   267
03A6:  INCF   57,F
03A7:  GOTO   37A
....................    } 
....................    delay_ms(500); 
03A8:  MOVLW  02
03A9:  MOVWF  58
03AA:  CLRF   2C
03AB:  BTFSC  0B.7
03AC:  BSF    2C.7
03AD:  BCF    0B.7
03AE:  MOVLW  FA
03AF:  MOVWF  69
03B0:  CALL   171
03B1:  BTFSC  2C.7
03B2:  BSF    0B.7
03B3:  DECFSZ 58,F
03B4:  GOTO   3AA
03B5:  RETURN
.................... } 
.................... short CompararClave(char *s1,char *s2) 
.................... { 
....................    for (int i = 0; i < tam_psw; ++i) 
03B6:  CLRF   58
03B7:  MOVF   58,W
03B8:  SUBLW  09
03B9:  BTFSS  03.0
03BA:  GOTO   3CC
....................       if(s1[i]!=s2[i]) 
03BB:  MOVF   56,W
03BC:  ADDWF  58,W
03BD:  MOVWF  04
03BE:  MOVF   00,W
03BF:  MOVWF  59
03C0:  MOVF   57,W
03C1:  ADDWF  58,W
03C2:  MOVWF  04
03C3:  MOVF   00,W
03C4:  SUBWF  59,W
03C5:  BTFSC  03.2
03C6:  GOTO   3CA
....................          return 0; 
03C7:  MOVLW  00
03C8:  MOVWF  21
03C9:  GOTO   3CE
03CA:  INCF   58,F
03CB:  GOTO   3B7
....................    return 1; 
03CC:  MOVLW  01
03CD:  MOVWF  21
03CE:  RETURN
.................... } 
.................... short IsMaster(char *sm) 
.................... { 
....................    for (int i = 0; i < tam_psw; ++i) 
*
044C:  CLRF   57
044D:  MOVF   57,W
044E:  SUBLW  09
044F:  BTFSS  03.0
0450:  GOTO   460
....................       if(master_key[i]!=sm[i]) 
0451:  MOVF   57,W
0452:  CALL   04F
0453:  MOVWF  58
0454:  MOVF   56,W
0455:  ADDWF  57,W
0456:  MOVWF  04
0457:  MOVF   00,W
0458:  SUBWF  58,W
0459:  BTFSC  03.2
045A:  GOTO   45E
....................          return 0; 
045B:  MOVLW  00
045C:  MOVWF  21
045D:  GOTO   462
045E:  INCF   57,F
045F:  GOTO   44D
....................    return 1; 
0460:  MOVLW  01
0461:  MOVWF  21
0462:  GOTO   5C6 (RETURN)
.................... } 
.................... char ReciveTecla() 
.................... { 
....................    pin_intext=IsTouched();  
*
0308:  BTFSS  21.0
0309:  BCF    05.1
030A:  BTFSC  21.0
030B:  BSF    05.1
....................    char tecla=kbd_getc(); 
*
035C:  MOVF   21,W
035D:  MOVWF  58
....................    if (tecla) 
035E:  MOVF   58,F
035F:  BTFSC  03.2
0360:  GOTO   366
....................    { 
....................       if(!ilumin) 
0361:  BTFSC  06.6
0362:  GOTO   365
....................       { 
....................          enable_interrupts(int_timer0); 
0363:  BSF    0B.5
....................          ilumin=true; 
0364:  BSF    06.6
....................       } 
....................       t0=0; 
0365:  CLRF   30
....................    }    
....................    return tecla; 
0366:  MOVF   58,W
0367:  MOVWF  21
0368:  RETURN
.................... } 
.................... short IsTouched() 
*
0294:  BCF    59.0
0295:  CLRF   5B
0296:  CLRF   5A
.................... { 
....................    short m_touch=false; 
....................    long value=0; 
....................    for(int i = 0; i < 40; ++i) 
0297:  CLRF   5C
0298:  MOVF   5C,W
0299:  SUBLW  27
029A:  BTFSS  03.0
029B:  GOTO   2F3
....................    { 
....................       trisadcb4=false; 
029C:  BSF    03.5
029D:  BCF    06.4
....................       trisadcb5=false; 
029E:  BCF    06.5
....................       adcB5=true; 
029F:  BCF    03.5
02A0:  BSF    06.5
....................       set_adc_channel(11); 
02A1:  MOVLW  2C
02A2:  MOVWF  21
02A3:  MOVF   1F,W
02A4:  ANDLW  C3
02A5:  IORWF  21,W
02A6:  MOVWF  1F
....................       delay_us(20); 
02A7:  MOVLW  06
02A8:  MOVWF  20
02A9:  DECFSZ 20,F
02AA:  GOTO   2A9
02AB:  NOP
....................       trisadcb4=true; 
02AC:  BSF    03.5
02AD:  BSF    06.4
....................       set_adc_channel(10); 
02AE:  MOVLW  28
02AF:  BCF    03.5
02B0:  MOVWF  21
02B1:  MOVF   1F,W
02B2:  ANDLW  C3
02B3:  IORWF  21,W
02B4:  MOVWF  1F
....................       value+=read_adc()/40;    
02B5:  BSF    1F.1
02B6:  BTFSC  1F.1
02B7:  GOTO   2B6
02B8:  MOVF   1E,W
02B9:  MOVWF  23
02BA:  BSF    03.5
02BB:  MOVF   1E,W
02BC:  BCF    03.5
02BD:  MOVWF  5D
02BE:  MOVF   23,W
02BF:  MOVWF  5E
02C0:  MOVF   5E,W
02C1:  MOVWF  60
02C2:  MOVF   5D,W
02C3:  MOVWF  5F
02C4:  CLRF   62
02C5:  MOVLW  28
02C6:  MOVWF  61
*
02EB:  MOVF   21,W
02EC:  ADDWF  5A,F
02ED:  MOVF   22,W
02EE:  BTFSC  03.0
02EF:  INCFSZ 22,W
02F0:  ADDWF  5B,F
02F1:  INCF   5C,F
02F2:  GOTO   298
....................    } 
....................    m_touch = (value<sensibilidad)? true : false; 
02F3:  MOVF   5B,W
02F4:  SUBLW  46
02F5:  BTFSS  03.0
02F6:  GOTO   2FF
02F7:  BTFSS  03.2
02F8:  GOTO   2FD
02F9:  MOVF   5A,W
02FA:  SUBLW  4F
02FB:  BTFSS  03.0
02FC:  GOTO   2FF
02FD:  MOVLW  01
02FE:  GOTO   300
02FF:  MOVLW  00
0300:  MOVWF  21
0301:  BCF    59.0
0302:  BTFSC  21.0
0303:  BSF    59.0
....................    return m_touch; 
0304:  MOVLW  00
0305:  BTFSC  59.0
0306:  MOVLW  01
0307:  MOVWF  21
.................... } 
.................... void Abrir() 
.................... { 
....................    pin_abrir=true; 
*
0185:  BSF    05.4
....................    for (int i = 0; i < 200; ++i) 
0186:  CLRF   67
0187:  MOVF   67,W
0188:  SUBLW  C7
0189:  BTFSS  03.0
018A:  GOTO   19A
....................    { 
....................       pin_abrir = (sensor)? false : true; 
018B:  BTFSS  05.0
018C:  GOTO   18F
018D:  MOVLW  00
018E:  GOTO   190
018F:  MOVLW  01
0190:  MOVWF  21
0191:  BTFSS  21.0
0192:  BCF    05.4
0193:  BTFSC  21.0
0194:  BSF    05.4
....................       delay_ms(9); 
0195:  MOVLW  09
0196:  MOVWF  69
0197:  CALL   171
0198:  INCF   67,F
0199:  GOTO   187
....................    } 
....................    pin_abrir=false; 
019A:  BCF    05.4
....................    pin_cerrar=true; 
019B:  BSF    05.5
....................    delay_ms(500); 
019C:  MOVLW  02
019D:  MOVWF  68
019E:  MOVLW  FA
019F:  MOVWF  69
01A0:  CALL   171
01A1:  DECFSZ 68,F
01A2:  GOTO   19E
....................    pin_cerrar=false; 
01A3:  BCF    05.5
....................    delay_ms(500); 
01A4:  MOVLW  02
01A5:  MOVWF  68
01A6:  MOVLW  FA
01A7:  MOVWF  69
01A8:  CALL   171
01A9:  DECFSZ 68,F
01AA:  GOTO   1A6
01AB:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 3C34   INTRC_IO NOWDT NOPUT MCLR PROTECT CPD NOBROWNOUT IESO FCMEN
